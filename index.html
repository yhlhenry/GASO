<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>GAS Graphviz</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- viz.js + worker (full.render.js includes all engines) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/viz.js/2.1.2/viz.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/viz.js/2.1.2/full.render.js"></script>

    <style>
      :root { color-scheme: light dark; }
      body { 
        font-family: 'Times New Roman', 'Georgia', serif; 
        margin: 0; 
        padding: 20px; 
        padding-bottom: 20px; /* 減少底部 padding */
        background: #f4f1e8; 
        background-image: 
          radial-gradient(circle at 20% 50%, rgba(139, 69, 19, 0.1) 0%, transparent 50%),
          radial-gradient(circle at 80% 20%, rgba(160, 82, 45, 0.1) 0%, transparent 50%),
          radial-gradient(circle at 40% 80%, rgba(101, 67, 33, 0.1) 0%, transparent 50%);
        min-height: 100vh;
        overflow-x: auto;
        overflow-y: auto;
        box-sizing: border-box;
      }
      
      .header {
        background: #faf8f3;
        border: 3px solid #8b4513;
        border-radius: 8px;
        padding: 25px;
        margin-bottom: 30px;
        box-shadow: 
          0 4px 8px rgba(0, 0, 0, 0.2),
          inset 0 1px 0 rgba(255, 255, 255, 0.3);
        position: relative;
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-wrap: wrap;
        gap: 20px;
        padding-right: 90px; /* 為控制面板按鈕留出空間 */
      }
      
      .header::before {
        content: '';
        position: absolute;
        top: -2px;
        left: -2px;
        right: -2px;
        bottom: -2px;
        background: linear-gradient(45deg, #8b4513, #a0522d, #8b4513);
        border-radius: 8px;
        z-index: -1;
      }
      
      h2 { 
        margin: 0; 
        font-size: 2.2rem;
        font-weight: bold;
        color: #8b4513;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        letter-spacing: 1px;
        font-family: 'Times New Roman', serif;
      }
      
      .title-section {
        flex: 1;
        min-width: 300px;
      }
      
      .subtitle {
        color: #654321;
        font-size: 1rem;
        font-weight: normal;
        font-style: italic;
        margin-top: 5px;
      }
      #graph { 
        width: 100%; 
        max-width: none; 
        overflow: auto; 
        border: 3px solid #8b4513; 
        border-radius: 8px; 
        background: #faf8f3; 
        transition: margin-right 0.3s ease;
        box-shadow: 
          0 4px 8px rgba(0, 0, 0, 0.2),
          inset 0 1px 0 rgba(255, 255, 255, 0.3);
        min-height: 400px;
        position: relative;
      }
      #zoomInner { 
        transform-origin: 0 0; 
        display: inline-block; 
        position: relative;
      }
      #zoomInner::before { 
        content: ''; 
        position: absolute; 
        top: -100px; 
        left: -100px; 
        right: -100px; 
        bottom: -100px; 
        background-image: url("https://raw.githubusercontent.com/yhlhenry/GASO/main/image/World_Map_By_ChatGPT_Fixed_By_Gemini.png"); 
        background-repeat: no-repeat; 
        background-position: center center; 
        background-size: cover; 
        opacity: 0.3; 
        z-index: -1; 
      }
      #zoomInner svg { background: transparent !important; position: relative; z-index: 1; }
      #zoomInner svg polygon[fill="#ffffff"] { fill: transparent !important; }
      
      /* 節點半透明漸層效果 */
      #zoomInner svg g.node rect,
      #zoomInner svg g.node ellipse,
      #zoomInner svg g.node polygon {
        fill: url(#nodeGradient) !important;
        stroke: none !important;
      }
      
      #zoomInner svg g.node text {
        fill: white !important;
        font-weight: bold !important;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5) !important;
      }
      .controls { display: flex; align-items: center; gap: .5rem; flex-wrap: wrap; margin: .5rem 0 1rem; }
      .controls input[type="range"] { width: 150px; }
      .controls button, .controls select { padding: .35rem .6rem; border: 1px solid #bbb; background: #f8f8f8; border-radius: 6px; cursor: pointer; }
      .controls button:active { transform: translateY(1px); }
      label { display: inline-flex; align-items: center; gap: .35rem; }
      .muted { color: #666; font-size: .9em; }
      .row { display: flex; gap: .75rem; align-items: center; flex-wrap: wrap; }

      /* 彈出視窗樣式 */
      .modal {
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.5);
        backdrop-filter: blur(2px);
      }

      .modal-content {
        background-color: #fefefe;
        margin: 10% auto;
        padding: 25px;
        border: 1px solid #888;
        width: 90%;
        max-width: 500px;
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        position: relative;
        animation: modalSlideIn 0.3s ease-out;
      }

      @keyframes modalSlideIn {
        from {
          opacity: 0;
          transform: translateY(-50px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .close {
        color: #aaa;
        float: right;
        font-size: 28px;
        font-weight: bold;
        cursor: pointer;
        position: absolute;
        right: 15px;
        top: 15px;
        line-height: 1;
      }

      .close:hover {
        color: #000;
      }

      /* 節點資訊樣式 */
      .node-info {
        margin-top: 15px;
      }

      .info-row {
        display: flex;
        margin-bottom: 12px;
        align-items: flex-start;
      }

      .info-label {
        font-weight: bold;
        color: #333;
        min-width: 60px;
        margin-right: 10px;
      }

      .info-value {
        color: #666;
        flex: 1;
      }

      .info-prompt {
        color: #666;
        flex: 1;
        line-height: 1.5;
        background: #f8f9fa;
        padding: 10px 50px 10px 10px; /* 右邊增加內邊距避免被按鈕遮住 */
        border-radius: 6px;
        border-left: 3px solid #007bff;
        position: relative;
        min-height: 40px; /* 確保有足夠高度容納按鈕 */
      }

      .copy-button {
        position: absolute;
        top: 6px;
        right: 6px;
        background: #007bff;
        color: white;
        border: none;
        border-radius: 4px;
        padding: 6px 10px;
        font-size: 11px;
        cursor: pointer;
        transition: all 0.2s ease;
        z-index: 10; /* 確保按鈕在最上層 */
        box-shadow: 0 1px 3px rgba(0,0,0,0.2); /* 添加陰影讓按鈕更明顯 */
      }

      .copy-button:hover {
        background: #0056b3;
        transform: scale(1.05);
      }

      .copy-button:active {
        transform: scale(0.95);
      }

      .copy-button.copied {
        background: #28a745;
      }

      .copy-button.copied::after {
        content: " ✓";
      }

      /* 狀態標籤樣式 */
      .status-todo {
        background: #e9ecef;
        color: #495057;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 0.85em;
      }

      .status-inprogress {
        background: #fff3cd;
        color: #856404;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 0.85em;
      }

      .status-done {
        background: #d4edda;
        color: #155724;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 0.85em;
      }

      .status- {
        background: #f8d7da;
        color: #721c24;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 0.85em;
      }

      /* 搜尋功能樣式 */
      .search-container {
        margin: 0;
        position: relative;
        flex: 1;
        max-width: 400px;
      }

      .search-box {
        position: relative;
        width: 100%;
      }

      .search-box::before {
        content: '🔍';
        position: absolute;
        right: 12px;
        top: 50%;
        transform: translateY(-50%);
        font-size: 16px;
        color: #8b7355;
        pointer-events: none;
        z-index: 1;
      }

      #searchInput {
        width: 100%;
        padding: 12px 40px 12px 16px; /* 右邊留出空間給放大鏡圖示 */
        border: 2px solid #8b4513;
        border-radius: 4px;
        font-size: 16px;
        box-sizing: border-box;
        transition: all 0.3s ease;
        background: #faf8f3;
        color: #8b4513;
        font-family: 'Times New Roman', serif;
        box-shadow: 
          inset 0 2px 4px rgba(0, 0, 0, 0.1),
          0 2px 4px rgba(0, 0, 0, 0.2);
      }

      #searchInput:focus {
        outline: none;
        border-color: #a0522d;
        box-shadow: 
          inset 0 2px 4px rgba(0, 0, 0, 0.1),
          0 0 0 3px rgba(160, 82, 45, 0.3),
          0 2px 4px rgba(0, 0, 0, 0.2);
        background: #fffef7;
      }

      #searchInput::placeholder {
        color: #8b7355;
        font-weight: normal;
        font-style: italic;
      }

      .search-results {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background: white;
        border: 1px solid #ddd;
        border-top: none;
        border-radius: 0 0 8px 8px;
        max-height: 300px;
        overflow-y: auto;
        z-index: 1000;
        display: none;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      }

      .search-results.show {
        display: block;
      }

      .search-result-item {
        padding: 12px 16px;
        cursor: pointer;
        border-bottom: 1px solid #f0f0f0;
        transition: background-color 0.2s ease;
      }

      .search-result-item:hover {
        background-color: #f8f9fa;
      }

      .search-result-item:last-child {
        border-bottom: none;
      }

      .search-result-title {
        font-weight: bold;
        color: #333;
        margin-bottom: 4px;
      }

      .search-result-subtitle {
        font-size: 0.9em;
        color: #666;
        line-height: 1.4;
      }

      .search-result-highlight {
        background-color: #fff3cd;
        padding: 1px 2px;
        border-radius: 2px;
      }

      .no-results {
        padding: 16px;
        text-align: center;
        color: #666;
        font-style: italic;
      }

      /* 節點形狀選擇器樣式優化 */
      #nodeShapeSelect {
        min-width: 120px;
      }

      /* 側邊面板樣式 */
      .sidebar {
        position: fixed;
        top: 0;
        right: -350px;
        width: 350px;
        height: 100vh;
        background: #faf8f3;
        border-left: 3px solid #8b4513;
        box-shadow: 
          -4px 0 12px rgba(0, 0, 0, 0.3),
          inset 1px 0 0 rgba(255, 255, 255, 0.2);
        transition: right 0.3s ease;
        z-index: 1000;
        overflow-y: auto;
        padding: 20px;
        box-sizing: border-box;
      }

      .sidebar.open {
        right: 0;
      }

      .sidebar-toggle {
        position: fixed;
        top: 20px;
        right: 20px;
        background: #8b4513;
        color: #faf8f3;
        border: 2px solid #654321;
        border-radius: 8px;
        width: 50px;
        height: 50px;
        font-size: 18px;
        cursor: pointer;
        box-shadow: 
          0 4px 8px rgba(0, 0, 0, 0.3),
          inset 0 1px 0 rgba(255, 255, 255, 0.2);
        transition: all 0.3s ease;
        z-index: 1001;
        font-family: 'Times New Roman', serif;
        font-weight: bold;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
      }

      .sidebar-toggle:hover {
        background: #a0522d;
        border-color: #8b4513;
        transform: scale(1.05);
        box-shadow: 
          0 6px 12px rgba(0, 0, 0, 0.4),
          inset 0 1px 0 rgba(255, 255, 255, 0.3);
      }

      .sidebar-toggle.open {
        right: 20px;
        background: #654321;
        border-color: #8b4513;
      }

      .sidebar-toggle.open:hover {
        background: #8b4513;
        border-color: #654321;
      }

      .sidebar-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 2px solid #dee2e6;
      }

      .sidebar-title {
        font-size: 18px;
        font-weight: bold;
        color: #333;
        margin: 0;
      }

      .sidebar-close {
        background: none;
        border: none;
        font-size: 24px;
        color: #666;
        cursor: pointer;
        padding: 0;
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .sidebar-close:hover {
        color: #333;
      }

      .control-group {
        margin-bottom: 25px;
        padding: 15px;
        background: #f4f1e8;
        border: 2px solid #8b4513;
        border-radius: 8px;
        box-shadow: 
          0 2px 4px rgba(0, 0, 0, 0.2),
          inset 0 1px 0 rgba(255, 255, 255, 0.3);
      }

      .control-group-title {
        font-size: 14px;
        font-weight: bold;
        color: #8b4513;
        margin-bottom: 12px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        font-family: 'Times New Roman', serif;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
      }

      .control-item {
        margin-bottom: 15px;
      }

      .control-item:last-child {
        margin-bottom: 0;
      }

      .control-item label {
        display: block;
        margin-bottom: 5px;
        font-size: 13px;
        color: #654321;
        font-weight: 500;
        font-family: 'Times New Roman', serif;
      }

      .control-item input[type="range"] {
        width: 100%;
        margin: 5px 0;
      }

      .control-item select {
        width: 100%;
        padding: 8px 12px;
        border: 2px solid #8b4513;
        border-radius: 4px;
        background: #faf8f3;
        font-size: 14px;
        color: #8b4513;
        font-family: 'Times New Roman', serif;
        box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1);
      }

      .control-item button {
        width: 100%;
        padding: 8px 12px;
        border: 2px solid #8b4513;
        border-radius: 4px;
        background: #faf8f3;
        cursor: pointer;
        font-size: 14px;
        color: #8b4513;
        font-family: 'Times New Roman', serif;
        font-weight: bold;
        transition: all 0.2s ease;
        box-shadow: 
          0 2px 4px rgba(0, 0, 0, 0.2),
          inset 0 1px 0 rgba(255, 255, 255, 0.3);
      }

      .control-item button:hover {
        background: #a0522d;
        color: #faf8f3;
        border-color: #654321;
        box-shadow: 
          0 3px 6px rgba(0, 0, 0, 0.3),
          inset 0 1px 0 rgba(255, 255, 255, 0.2);
      }

      .control-item button.danger {
        background: #8b4513;
        color: #faf8f3;
        border-color: #654321;
      }

      .control-item button.danger:hover {
        background: #654321;
        border-color: #8b4513;
      }

      .value-display {
        font-size: 12px;
        color: #8b4513;
        font-weight: bold;
        margin-left: 10px;
        font-family: 'Times New Roman', serif;
      }

      /* 載入動畫樣式 */
      .loading-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #f4f1e8;
        background-image: 
          radial-gradient(circle at 20% 50%, rgba(139, 69, 19, 0.1) 0%, transparent 50%),
          radial-gradient(circle at 80% 20%, rgba(160, 82, 45, 0.1) 0%, transparent 50%),
          radial-gradient(circle at 40% 80%, rgba(101, 67, 33, 0.1) 0%, transparent 50%);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        transition: opacity 0.5s ease-out;
      }

      .loading-container.hidden {
        opacity: 0;
        pointer-events: none;
      }

      .loading-spinner {
        width: 80px;
        height: 80px;
        border: 6px solid #8b4513;
        border-top: 6px solid #a0522d;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-bottom: 30px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      .loading-text {
        font-family: 'Times New Roman', serif;
        font-size: 24px;
        font-weight: bold;
        color: #8b4513;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        margin-bottom: 20px;
        animation: pulse 2s ease-in-out infinite;
      }

      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
      }

      .loading-dots {
        display: flex;
        gap: 8px;
        margin-top: 10px;
      }

      .loading-dot {
        width: 12px;
        height: 12px;
        background: #8b4513;
        border-radius: 50%;
        animation: bounce 1.4s ease-in-out infinite both;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .loading-dot:nth-child(1) { animation-delay: -0.32s; }
      .loading-dot:nth-child(2) { animation-delay: -0.16s; }
      .loading-dot:nth-child(3) { animation-delay: 0s; }

      @keyframes bounce {
        0%, 80%, 100% {
          transform: scale(0);
        }
        40% {
          transform: scale(1);
        }
      }

      .loading-progress {
        width: 300px;
        height: 6px;
        background: rgba(139, 69, 19, 0.2);
        border-radius: 3px;
        overflow: hidden;
        margin-top: 20px;
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2);
      }

      .loading-progress-bar {
        height: 100%;
        background: linear-gradient(90deg, #8b4513, #a0522d, #8b4513);
        background-size: 200% 100%;
        animation: progressMove 2s ease-in-out infinite;
        border-radius: 3px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      }

      @keyframes progressMove {
        0% { 
          width: 0%;
          background-position: 0% 50%;
        }
        50% { 
          width: 70%;
          background-position: 100% 50%;
        }
        100% { 
          width: 100%;
          background-position: 0% 50%;
        }
      }

      .loading-subtitle {
        font-family: 'Times New Roman', serif;
        font-size: 16px;
        color: #654321;
        font-style: italic;
        margin-top: 15px;
        opacity: 0.8;
      }

      /* 響應式設計優化 */
      @media (max-width: 768px) {
        .sidebar {
          width: 100%;
          right: -100%;
        }

        .sidebar.open {
          right: 0;
        }

        .sidebar-toggle.open {
          right: 20px;
        }

        .controls.row {
          flex-direction: column;
          align-items: flex-start;
        }
        
        .controls.row label {
          margin-left: 0 !important;
          margin-top: 0.5rem;
        }
        
        #nodeShapeSelect {
          min-width: 100%;
        }

        .loading-text {
          font-size: 20px;
        }

        .loading-progress {
          width: 250px;
        }
      }
    </style>
  </head>
  <body>
    <!-- 載入動畫 -->
    <div class="loading-container" id="loadingContainer">
      <div class="loading-spinner"></div>
      <div class="loading-text">正在載入學習地圖</div>
      <div class="loading-dots">
        <div class="loading-dot"></div>
        <div class="loading-dot"></div>
        <div class="loading-dot"></div>
      </div>
      <div class="loading-progress">
        <div class="loading-progress-bar"></div>
      </div>
      <div class="loading-subtitle">探索 Google Apps Script 的無限可能</div>
    </div>

    <!-- 頁面標題和搜尋區域 -->
    <div class="header">
      <div class="title-section">
        <h2>Google Apps Script Odyssey</h2>
        <div class="subtitle">探索 Google Apps Script 學習路徑的視覺化地圖</div>
      </div>
      
      <!-- 搜尋功能 -->
      <div class="search-container">
        <div class="search-box">
          <input type="text" id="searchInput" placeholder="搜尋節點..." autocomplete="off" />
          <div id="searchResults" class="search-results"></div>
        </div>
      </div>
    </div>

    <!-- 側邊面板切換按鈕 -->
    <button class="sidebar-toggle" id="sidebarToggle">⚙️</button>

    <!-- 側邊控制面板 -->
    <div class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <h3 class="sidebar-title">控制面板</h3>
        <button class="sidebar-close" id="sidebarClose">×</button>
      </div>

      <!-- 縮放控制組 -->
      <div class="control-group">
        <div class="control-group-title">縮放控制</div>
        <div class="control-item">
          <label>縮放比例</label>
          <input id="zoomRange" type="range" min="25" max="400" step="5" value="100" />
          <span id="zoomLabel" class="value-display">100%</span>
        </div>
        <div class="control-item">
          <button id="zoomOut">縮小 (−)</button>
        </div>
        <div class="control-item">
          <button id="zoomIn">放大 (＋)</button>
        </div>
        <div class="control-item">
          <button id="fitWidth">適應螢幕寬度</button>
        </div>
        <div class="control-item">
          <button id="resetZoom">重設縮放</button>
        </div>
        <div class="control-item">
          <small style="color: #666;">(Ctrl+滾輪可縮放)</small>
        </div>
      </div>

      <!-- 版面配置控制組 -->
      <div class="control-group">
        <div class="control-group-title">版面配置</div>
        <div class="control-item">
          <label>Layout 引擎</label>
          <select id="layoutSelect">
            <option value="dot">dot（階層式）</option>
            <option value="neato" selected>neato（力導向）</option>
            <option value="fdp">fdp（力導向）</option>
            <option value="twopi">twopi（放射狀）</option>
            <option value="circo">circo（圓環）</option>
            <option value="osage">osage（叢集）</option>
            <option value="patchwork">patchwork（樹圖）</option>
          </select>
        </div>
        <div class="control-item">
          <label>方向 (rankdir)</label>
          <select id="rankdirSelect">
            <option value="TB">TB（上→下）</option>
            <option value="LR">LR（左→右）</option>
            <option value="BT">BT（下→上）</option>
            <option value="RL">RL（右→左）</option>
          </select>
        </div>
        <div class="control-item">
          <label>邊線樣式</label>
          <select id="splinesSelect">
            <option value="curved">彎曲邊</option>
            <option value="line">直線邊</option>
          </select>
        </div>
        <div class="control-item">
          <label>節點形狀</label>
          <select id="nodeShapeSelect">
            <option value="ellipse">橢圓形</option>
            <option value="box" selected>矩形</option>
            <option value="diamond">菱形</option>
            <option value="triangle">三角形</option>
            <option value="circle">圓形</option>
            <option value="hexagon">六角形</option>
            <option value="octagon">八角形</option>
            <option value="star">星形</option>
            <option value="house">房子形</option>
            <option value="invhouse">倒房子形</option>
            <option value="trapezium">梯形</option>
            <option value="parallelogram">平行四邊形</option>
          </select>
        </div>
      </div>

      <!-- 字體控制組 -->
      <div class="control-group">
        <div class="control-group-title">字體設定</div>
        <div class="control-item">
          <label>字體大小</label>
          <input id="fontRange" type="range" min="8" max="40" step="1" value="14" />
          <span id="fontLabel" class="value-display">14px</span>
        </div>
        <div class="control-item">
          <button id="fontSmaller">字體縮小</button>
        </div>
        <div class="control-item">
          <button id="fontBigger">字體放大</button>
        </div>
        <div class="control-item">
          <button id="resetFont">重設字體</button>
        </div>
      </div>

      <!-- 路徑控制組 -->
      <div class="control-group">
        <div class="control-group-title">路徑控制</div>
        <div class="control-item">
          <button id="clearPathHighlight" class="danger">清除路徑高亮</button>
        </div>
      </div>
    </div>

    <div id="graph">
      <div id="zoomInner"></div>
    </div>

    <!-- 節點資訊彈出視窗 -->
    <div id="nodeModal" class="modal" style="display: none;">
      <div class="modal-content">
        <span class="close">&times;</span>
        <h3 id="modalTitle">節點資訊</h3>
        <div id="modalContent"></div>
      </div>
    </div>

    <script>
      const state = {
        scalePct: 100,
        origW: null,
        origH: null,
        fontSize: 14,
        origFontSize: 14,
        engine: localStorage.getItem("gv_engine") || "neato",
        rankdir: localStorage.getItem("gv_rankdir") || "TB",
        splines: localStorage.getItem("gv_splines") || "line",
        nodeShape: localStorage.getItem("gv_nodeShape") || "box",
        dot: "",
        nodeDetails: [], // 儲存節點詳細資訊
        edgeDetails: [], // 儲存邊詳細資訊
        adjacencyList: {}, // 鄰接表
        highlightedPath: [], // 當前高亮的路徑
        backgroundImageUrl: "" // 從伺服器傳來的背景圖 URL（可覆寫預設）
      };

      const $ = (id) => document.getElementById(id);
      const zoomInner = $("zoomInner");
      const graph = $("graph");
      const zoomRange = $("zoomRange");
      const zoomLabel = $("zoomLabel");
      const fontRange = $("fontRange");
      const fontLabel = $("fontLabel");
      const layoutSelect = $("layoutSelect");
      const rankdirSelect = $("rankdirSelect");
      const splinesSelect = $("splinesSelect");
      const nodeShapeSelect = $("nodeShapeSelect");
      const searchInput = $("searchInput");
      const searchResults = $("searchResults");
      const sidebar = $("sidebar");
      const sidebarToggle = $("sidebarToggle");
      const sidebarClose = $("sidebarClose");

      if (layoutSelect) layoutSelect.value = state.engine;
      if (rankdirSelect) rankdirSelect.value = state.rankdir;
      if (splinesSelect) splinesSelect.value = state.splines;
      if (nodeShapeSelect) nodeShapeSelect.value = state.nodeShape;

      // --- 側邊面板控制 ---
      function toggleSidebar() {
        sidebar.classList.toggle('open');
        sidebarToggle.classList.toggle('open');
        adjustGraphMargin();
      }

      function closeSidebar() {
        sidebar.classList.remove('open');
        sidebarToggle.classList.remove('open');
        adjustGraphMargin();
      }

      function adjustGraphMargin() {
        const graph = $("graph");
        if (sidebar.classList.contains('open')) {
          // 在桌面版時調整邊距
          if (window.innerWidth > 768) {
            graph.style.marginRight = '350px';
          }
        } else {
          graph.style.marginRight = '0';
        }
      }

      // 監聽視窗大小變化
      window.addEventListener('resize', adjustGraphMargin);

      // 側邊面板事件監聽
      if (sidebarToggle) {
        sidebarToggle.addEventListener('click', toggleSidebar);
      }

      if (sidebarClose) {
        sidebarClose.addEventListener('click', closeSidebar);
      }

      // 點擊外部關閉側邊面板
      document.addEventListener('click', function(e) {
        if (sidebar.classList.contains('open') && 
            !sidebar.contains(e.target) && 
            !sidebarToggle.contains(e.target)) {
          closeSidebar();
        }
      });

      // ESC 鍵關閉側邊面板
      document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && sidebar.classList.contains('open')) {
          closeSidebar();
        }
      });

      // --- 建立/重建 Viz 實例（避免 worker 卡住） ---
      let viz;
      function newViz() {
        try { viz && viz.terminate && viz.terminate(); } catch (_) {}
        viz = new Viz();
      }
      newViz();

      // --- 整體縮放 ---
      function applyZoom(pct) {
        state.scalePct = Math.max(10, Math.min(800, pct));
        const scale = state.scalePct / 100;
        zoomInner.style.transform = `scale(${scale})`;
        zoomLabel.textContent = `${state.scalePct}%`;
        zoomRange.value = String(state.scalePct);
        
        // 縮放後重新調整頁面大小
        if (state.origW && state.origH) {
          const scaledWidth = state.origW * scale;
          const scaledHeight = state.origH * scale;
          adjustPageSizeToGraph(scaledWidth, scaledHeight);
        }
      }
      function fitToWidth() {
        if (!state.origW) return;
        const containerWidth = graph.clientWidth;
        const scale = containerWidth / state.origW;
        applyZoom(Math.round(scale * 100));
      }
      function resetZoom() {
        applyZoom(100);
        graph.scrollTo({ left: 0, top: 0, behavior: "smooth" });
      }

      // --- 字體大小 ---
      function applyFontSize(px) {
        state.fontSize = Math.max(6, Math.min(80, px));
        const texts = zoomInner.querySelectorAll("text");
        texts.forEach(t => t.setAttribute("font-size", state.fontSize));
        fontLabel.textContent = `${state.fontSize}px`;
        fontRange.value = state.fontSize;
      }
      function resetFont() { applyFontSize(state.origFontSize); }

      // --- rankdir 注入（僅 dot 引擎有效） ---
      function applyRankdirToDot(src, dir) {
        try {
          if (!src) return src;
          // 移除既有 rankdir 設定
          let cleaned = src.replace(/\brankdir\s*=\s*"?[A-Z]{2}"?\s*;?/gi, "");
          // 在第一個 { 之後注入 rankdir
          const i = cleaned.indexOf('{');
          if (i !== -1) {
            return cleaned.slice(0, i + 1) + `\n  rankdir=${dir};` + cleaned.slice(i + 1);
          }
          return `digraph G { rankdir=${dir}; ${cleaned} }`;
        } catch (e) {
          console.warn('applyRankdirToDot failed, fallback raw DOT');
          return src;
        }
      }

      // --- splines 注入（所有引擎都有效） ---
      function applySplinesToDot(src, splinesType) {
        try {
          if (!src) return src;
          // 移除既有 splines 設定
          let cleaned = src.replace(/\bsplines\s*=\s*"?[a-zA-Z]+"?\s*;?/gi, "");
          // 在第一個 { 之後注入 splines
          const i = cleaned.indexOf('{');
          if (i !== -1) {
            return cleaned.slice(0, i + 1) + `\n  splines=${splinesType};` + cleaned.slice(i + 1);
          }
          return `digraph G { splines=${splinesType}; ${cleaned} }`;
        } catch (e) {
          console.warn('applySplinesToDot failed, fallback raw DOT');
          return src;
        }
      }

      // --- 節點形狀注入（所有引擎都有效） ---
      function applyNodeShapeToDot(src, shapeType) {
        try {
          if (!src) return src;
          // 移除既有 shape 設定
          let cleaned = src.replace(/\bshape\s*=\s*"?[a-zA-Z]+"?\s*;?/gi, "");
          // 在第一個 { 之後注入節點形狀
          const i = cleaned.indexOf('{');
          if (i !== -1) {
            return cleaned.slice(0, i + 1) + `\n  node [shape=${shapeType}];` + cleaned.slice(i + 1);
          }
          return `digraph G { node [shape=${shapeType}]; ${cleaned} }`;
        } catch (e) {
          console.warn('applyNodeShapeToDot failed, fallback raw DOT');
          return src;
        }
      }

      // --- 依指定引擎渲染 DOT ---
      async function renderGraph() {
        if (!state.dot) return Promise.resolve();
        try {
          console.log(`[render] engine=%s, splines=%s, nodeShape=%s`, state.engine, state.splines, state.nodeShape);
          const src = state.dot;
          let dotToUse = applySplinesToDot(src, state.splines);
          dotToUse = applyNodeShapeToDot(dotToUse, state.nodeShape);
          dotToUse = (state.engine === 'dot') ? applyRankdirToDot(dotToUse, state.rankdir) : dotToUse;
          const svg = await viz.renderSVGElement(dotToUse, { engine: state.engine });

          const rawW = svg.getAttribute("width");
          const rawH = svg.getAttribute("height");
          const origW = rawW ? parseFloat(rawW) : (svg.viewBox?.baseVal?.width || svg.getBBox().width);
          const origH = rawH ? parseFloat(rawH) : (svg.viewBox?.baseVal?.height || svg.getBBox().height);
          state.origW = origW; state.origH = origH;
          
          console.log(`=== Graphviz 尺寸資訊 ===`);
          console.log(`原始寬度 (origW): ${origW}px`);
          console.log(`原始高度 (origH): ${origH}px`);
          console.log(`SVG width 屬性: ${rawW}`);
          console.log(`SVG height 屬性: ${rawH}`);
          console.log(`SVG viewBox: ${svg.viewBox?.baseVal?.width || 'N/A'} x ${svg.viewBox?.baseVal?.height || 'N/A'}`);
          console.log(`SVG getBBox: ${svg.getBBox().width} x ${svg.getBBox().height}`);
          console.log(`========================`);

          const firstText = svg.querySelector("text");
          if (firstText && state.origFontSize === 14 && state.fontSize === 14) {
            state.origFontSize = parseInt(firstText.getAttribute("font-size")) || 14;
            state.fontSize = state.origFontSize;
            fontRange.value = state.origFontSize;
            fontLabel.textContent = `${state.origFontSize}px`;
          }

          // 設置原始尺寸，但限制在合理範圍內
          const maxReasonableWidth = window.innerWidth * 3; // 最大寬度為螢幕寬度的3倍
          const maxReasonableHeight = window.innerHeight * 3; // 最大高度為螢幕高度的3倍
          
          const finalWidth = Math.min(origW, maxReasonableWidth);
          const finalHeight = Math.min(origH, maxReasonableHeight);
          
          zoomInner.style.width = finalWidth + "px";
          zoomInner.style.height = finalHeight + "px";
          
          console.log(`原始尺寸: ${origW}x${origH}, 限制後尺寸: ${finalWidth}x${finalHeight}`);

          svg.setAttribute("preserveAspectRatio", "xMidYMid meet");
          if (!svg.getAttribute("viewBox")) svg.setAttribute("viewBox", `0 0 ${origW} ${origH}`);
          svg.removeAttribute("width");
          svg.removeAttribute("height");

          // 動態調整頁面大小以適應地圖（使用限制後的尺寸）
          adjustPageSizeToGraph(finalWidth, finalHeight);

          // 添加漸層定義
          const defs = svg.querySelector('defs') || svg.insertBefore(document.createElementNS('http://www.w3.org/2000/svg', 'defs'), svg.firstChild);
          
          // 創建漸層定義（如果不存在）
          if (!defs.querySelector('#nodeGradient')) {
            const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
            gradient.setAttribute('id', 'nodeGradient');
            gradient.setAttribute('cx', '50%');
            gradient.setAttribute('cy', '50%');
            gradient.setAttribute('r', '50%');
            
            const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
            stop1.setAttribute('offset', '0%');
            stop1.setAttribute('stop-color', 'rgba(160, 82, 45, 1.0)');
            
            const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
            stop2.setAttribute('offset', '100%');
            stop2.setAttribute('stop-color', 'rgba(139, 69, 19, 0)');
            
            gradient.appendChild(stop1);
            gradient.appendChild(stop2);
            defs.appendChild(gradient);
          }

          // 直接修改所有節點的 fill 屬性為漸層
          const nodeElements = svg.querySelectorAll('g.node polygon, g.node rect, g.node ellipse');
          nodeElements.forEach(element => {
            element.setAttribute('fill', 'url(#nodeGradient)');
            element.setAttribute('stroke', 'none');
          });

          zoomInner.innerHTML = "";
          zoomInner.appendChild(svg);

          // 為每個節點添加點擊事件
          addNodeClickEvents(svg);

          applyZoom(state.scalePct);
          applyFontSize(state.fontSize);
          
          // 自動適應螢幕寬度
          setTimeout(() => {
            fitToWidth();
          }, 100);
        } catch (err) {
          console.error("render error:", err);
          // worker 可能壞掉，重建後再試一次
          newViz();
          try {
            const src = state.dot;
            let dotToUse = applySplinesToDot(src, state.splines);
            dotToUse = applyNodeShapeToDot(dotToUse, state.nodeShape);
            dotToUse = (state.engine === 'dot') ? applyRankdirToDot(dotToUse, state.rankdir) : dotToUse;
            const svg = await viz.renderSVGElement(dotToUse, { engine: state.engine });
            
            // 添加漸層定義
            const defs = svg.querySelector('defs') || svg.insertBefore(document.createElementNS('http://www.w3.org/2000/svg', 'defs'), svg.firstChild);
            
            // 創建漸層定義（如果不存在）
            if (!defs.querySelector('#nodeGradient')) {
              const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
              gradient.setAttribute('id', 'nodeGradient');
              gradient.setAttribute('cx', '50%');
              gradient.setAttribute('cy', '50%');
              gradient.setAttribute('r', '50%');
              
              const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
              stop1.setAttribute('offset', '0%');
              stop1.setAttribute('stop-color', 'rgba(160, 82, 45, 0.9)');
              
              const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
              stop2.setAttribute('offset', '100%');
              stop2.setAttribute('stop-color', 'rgba(139, 69, 19, 0.4)');
              
              gradient.appendChild(stop1);
              gradient.appendChild(stop2);
              defs.appendChild(gradient);
            }

            // 直接修改所有節點的 fill 屬性為漸層
            const nodeElements = svg.querySelectorAll('g.node polygon, g.node rect, g.node ellipse');
            nodeElements.forEach(element => {
              element.setAttribute('fill', 'url(#nodeGradient)');
              element.setAttribute('stroke', 'none');
            });
            
            zoomInner.innerHTML = "";
            zoomInner.appendChild(svg);
            
            // 為每個節點添加點擊事件
            addNodeClickEvents(svg);
            
            applyZoom(state.scalePct);
            applyFontSize(state.fontSize);
            
            // 自動適應螢幕寬度
            setTimeout(() => {
              fitToWidth();
            }, 100);
          } catch (e2) {
            graph.textContent = `Graph render failed with engine "${state.engine}".`;
          }
        }
        return Promise.resolve();
      }

      // --- UI 綁定 ---
      zoomRange.addEventListener("input", (e) => applyZoom(parseInt(e.target.value, 10)));
      $("zoomIn").addEventListener("click", () => applyZoom(state.scalePct + 10));
      $("zoomOut").addEventListener("click", () => applyZoom(state.scalePct - 10));
      $("fitWidth").addEventListener("click", fitToWidth);
      $("resetZoom").addEventListener("click", resetZoom);

      fontRange.addEventListener("input", (e) => applyFontSize(parseInt(e.target.value, 10)));
      $("fontBigger").addEventListener("click", () => applyFontSize(state.fontSize + 2));
      $("fontSmaller").addEventListener("click", () => applyFontSize(state.fontSize - 2));
      $("resetFont").addEventListener("click", resetFont);
      $("clearPathHighlight").addEventListener("click", clearPathHighlight);

      graph.addEventListener("wheel", (e) => {
        if (!e.ctrlKey) return;
        e.preventDefault();
        const delta = Math.sign(e.deltaY);
        applyZoom(state.scalePct + (delta > 0 ? -5 : 5));
      }, { passive: false });

      // 監聽 layout 切換
      if (layoutSelect) {
        layoutSelect.addEventListener("change", async (e) => {
          state.engine = e.target.value;
          localStorage.setItem("gv_engine", state.engine);
          console.log(`[engine] changed to %s`, state.engine);
          await renderGraph();
        });
      }
      
      // 監聽 rankdir 切換（僅 dot 有效）
      if (rankdirSelect) {
        rankdirSelect.addEventListener("change", async (e) => {
          state.rankdir = e.target.value;
          localStorage.setItem("gv_rankdir", state.rankdir);
          await renderGraph(); // 重新渲染；對非 dot 引擎本來就不會有影響
        });
      }

      // 監聽 splines 切換（所有引擎都有效）
      if (splinesSelect) {
        splinesSelect.addEventListener("change", async (e) => {
          state.splines = e.target.value;
          localStorage.setItem("gv_splines", state.splines);
          console.log(`[splines] changed to %s`, state.splines);
          await renderGraph(); // 重新渲染
        });
      }

      // 監聽節點形狀切換（所有引擎都有效）
      if (nodeShapeSelect) {
        nodeShapeSelect.addEventListener("change", async (e) => {
          state.nodeShape = e.target.value;
          localStorage.setItem("gv_nodeShape", state.nodeShape);
          console.log(`[nodeShape] changed to %s`, state.nodeShape);
          await renderGraph(); // 重新渲染
        });
      }
      // --- 路徑查找和高亮功能 ---
      
      // 使用 BFS 找到從起點到目標節點的最短路徑
      function findPathToNode(targetNodeId) {
        console.log("=== 路徑查找調試 ===");
        console.log("目標節點 ID:", targetNodeId);
        
        // 找到實際的起點（沒有入邊的節點）
        const startNodes = findStartNodes();
        console.log("找到的起點節點:", startNodes);
        
        if (startNodes.length === 0) {
          console.log("沒有找到起點節點");
          return [];
        }
        
        // 使用第一個起點作為起始點
        const startNode = startNodes[0];
        console.log("使用起點:", startNode);
        
        // 檢查目標節點是否存在
        if (!state.adjacencyList[targetNodeId]) {
          console.log(`目標節點 '${targetNodeId}' 不存在於鄰接表中`);
          console.log("可用的節點 ID:", Object.keys(state.adjacencyList));
          return [];
        }
        
        // 從起點開始尋找所有路徑
        console.log(`從起點 '${startNode}' 尋找所有路徑到 '${targetNodeId}'`);
        console.log("鄰接表:", state.adjacencyList);
        const allPaths = findAllPaths(startNode, targetNodeId);
        console.log("找到的所有路徑:", allPaths);
        return allPaths;
      }
      
      // 找到起點（沒有入邊的節點）
      function findStartNodes() {
        console.log("=== 尋找起點節點 ===");
        const allNodes = new Set(Object.keys(state.adjacencyList));
        const hasIncoming = new Set();
        
        console.log("所有節點:", Array.from(allNodes));
        
        // 找出所有有入邊的節點
        Object.entries(state.adjacencyList).forEach(([source, neighbors]) => {
          neighbors.forEach(neighbor => {
            hasIncoming.add(neighbor);
            console.log(`節點 ${source} -> ${neighbor} (${neighbor} 有入邊)`);
          });
        });
        
        console.log("有入邊的節點:", Array.from(hasIncoming));
        
        // 起點是沒有入邊的節點
        const startNodes = Array.from(allNodes).filter(node => !hasIncoming.has(node));
        console.log("起點節點（沒有入邊的節點）:", startNodes);
        
        return startNodes;
      }
      
      // BFS 路徑查找 - 找到所有可能的路徑
      function findAllPaths(start, target) {
        console.log("=== 查找所有路徑開始 ===");
        console.log("起點:", start);
        console.log("目標:", target);
        
        const allPaths = [];
        const queue = [[start]];
        let step = 0;
        
        while (queue.length > 0) {
          step++;
          const path = queue.shift();
          const current = path[path.length - 1];
          
          console.log(`步驟 ${step}: 當前節點 ${current}, 路徑:`, path);
          
          if (current === target) {
            console.log(`找到目標節點！路徑:`, path);
            allPaths.push([...path]);
            continue; // 繼續尋找其他路徑
          }
          
          const neighbors = state.adjacencyList[current] || [];
          console.log(`節點 ${current} 的鄰居:`, neighbors);
          
          for (const neighbor of neighbors) {
            // 避免循環路徑（同一個節點在路徑中出現多次）
            if (!path.includes(neighbor)) {
              const newPath = [...path, neighbor];
              queue.push(newPath);
              console.log(`添加新路徑:`, newPath);
            } else {
              console.log(`節點 ${neighbor} 已在路徑中，跳過以避免循環`);
            }
          }
        }
        
        console.log(`找到 ${allPaths.length} 條路徑:`, allPaths);
        return allPaths;
      }
      
      // 保留原來的 BFS 函數作為備用
      function bfsPath(start, target) {
        const allPaths = findAllPaths(start, target);
        return allPaths.length > 0 ? allPaths[0] : []; // 返回第一條路徑
      }
      
      // 高亮單條路徑上的邊
      function highlightSinglePath(path) {
        if (path.length < 2) return;
        
        const svg = zoomInner.querySelector('svg');
        if (!svg) return;
        
        // 高亮路徑上的邊
        for (let i = 0; i < path.length - 1; i++) {
          const source = path[i];
          const target = path[i + 1];
          
          // 找到對應的邊元素
          const edgeId = `${source}_${target}`;
          const edgeElement = svg.querySelector(`#${edgeId}`);
          
          if (edgeElement) {
            // 找到邊元素內部的 path 元素（實際繪製線條的元素）
            const pathElement = edgeElement.querySelector('path');
            const polygonElement = edgeElement.querySelector('polygon'); // 箭頭元素
            
            if (pathElement) {
              // 對 path 元素應用高亮樣式 - 10px 綠色實線
              pathElement.style.setProperty('stroke', '#00ff00', 'important');
              pathElement.style.setProperty('stroke-width', '10px', 'important');
              pathElement.style.removeProperty('stroke-dasharray'); // 移除虛線，變成實線
              pathElement.style.setProperty('animation', 'pathPulse 2s infinite', 'important');
              
              // 對箭頭元素也應用高亮樣式
              if (polygonElement) {
                polygonElement.style.setProperty('fill', '#00ff00', 'important');
                polygonElement.style.setProperty('stroke', '#00ff00', 'important');
              }
              
              // 添加高亮類別到整個邊元素
              edgeElement.classList.add('path-highlighted');
              
              // 記錄高亮的邊元素和其子元素
              state.highlightedPath.push({
                edge: edgeElement,
                path: pathElement,
                polygon: polygonElement
              });
              
              console.log(`高亮邊: ${edgeId}`, { edgeElement, pathElement, polygonElement });
            } else {
              console.log(`邊元素 ${edgeId} 中找不到 path 元素`);
            }
          } else {
            console.log(`找不到邊元素: ${edgeId}`);
          }
        }
      }
      
      // 高亮多條路徑
      function highlightAllPaths(allPaths) {
        // 先清除之前的高亮
        clearPathHighlight();
        
        if (allPaths.length === 0) return;
        
        // 確保樣式已添加
        addPathHighlightStyles();
        
        console.log(`開始高亮 ${allPaths.length} 條路徑`);
        
        // 高亮每條路徑
        allPaths.forEach((path, index) => {
          console.log(`高亮第 ${index + 1} 條路徑:`, path);
          highlightSinglePath(path);
        });
        
        console.log(`完成高亮，共高亮了 ${state.highlightedPath.length} 條邊`);
      }
      
      // 保持向後兼容的函數
      function highlightPath(path) {
        if (Array.isArray(path) && path.length > 0 && Array.isArray(path[0])) {
          // 如果傳入的是多條路徑
          highlightAllPaths(path);
        } else {
          // 如果傳入的是單條路徑
          highlightAllPaths([path]);
        }
      }
      
      // 添加動畫樣式和高亮類別
      function addPathHighlightStyles() {
        if (!document.getElementById('pathHighlightStyle')) {
          const style = document.createElement('style');
          style.id = 'pathHighlightStyle';
          style.textContent = `
            @keyframes pathPulse {
              0%, 100% { opacity: 1; }
              50% { opacity: 0.6; }
            }
            
            .path-highlighted {
              stroke: #00ff00 !important;
              stroke-width: 10px !important;
              animation: pathPulse 2s infinite !important;
            }
          `;
          document.head.appendChild(style);
        }
      }
      
      // 清除路徑高亮
      function clearPathHighlight() {
        state.highlightedPath.forEach(highlightedItem => {
          // 處理新的數據結構
          if (highlightedItem.edge) {
            // 清除邊元素的樣式
            highlightedItem.edge.classList.remove('path-highlighted');
            
            // 清除 path 元素的樣式
            if (highlightedItem.path) {
              highlightedItem.path.style.removeProperty('stroke');
              highlightedItem.path.style.removeProperty('stroke-width');
              highlightedItem.path.style.removeProperty('stroke-dasharray');
              highlightedItem.path.style.removeProperty('animation');
            }
            
            // 清除箭頭元素的樣式
            if (highlightedItem.polygon) {
              highlightedItem.polygon.style.removeProperty('fill');
              highlightedItem.polygon.style.removeProperty('stroke');
            }
          } else {
            // 處理舊的數據結構（向後兼容）
            highlightedItem.style.removeProperty('stroke');
            highlightedItem.style.removeProperty('stroke-width');
            highlightedItem.style.removeProperty('stroke-dasharray');
            highlightedItem.style.removeProperty('animation');
            highlightedItem.classList.remove('path-highlighted');
          }
        });
        state.highlightedPath = [];
        console.log("已清除所有路徑高亮");
      }

      // --- 節點點擊事件處理 ---
      function addNodeClickEvents(svg) {
        const nodes = svg.querySelectorAll('g.node');
        nodes.forEach(node => {
          node.style.cursor = 'pointer';
          
          // 添加 hover 效果
          node.addEventListener('mouseenter', () => {
            node.style.opacity = '0.8';
          });
          
          node.addEventListener('mouseleave', () => {
            node.style.opacity = '1';
          });
          
          // 添加點擊事件
          node.addEventListener('click', (e) => {
            e.stopPropagation();
            const svgNodeId = node.id; // SVG 中的節點 ID (如 node40)
            const nodeLabel = node.querySelector('text')?.textContent || svgNodeId;
            
            // 調試信息：顯示所有可用的節點 ID
            console.log("=== 調試信息 ===");
            console.log("SVG 節點 ID:", svgNodeId);
            console.log("節點標籤:", nodeLabel);
            console.log("鄰接表中的所有節點 ID:", Object.keys(state.adjacencyList));
            console.log("nodeDetails 中的所有節點:", state.nodeDetails.map(n => ({id: n.id, label: n.label})));
            
            // 通過標籤找到實際的節點 ID
            const actualNodeDetail = state.nodeDetails.find(n => n.label === nodeLabel);
            const actualNodeId = actualNodeDetail ? actualNodeDetail.id : svgNodeId;
            
            console.log("通過標籤找到的實際節點 ID:", actualNodeId);
            
            // 查找並高亮所有路徑
            const allPaths = findPathToNode(actualNodeId);
            if (allPaths.length > 0) {
              console.log(`找到從起點到 ${actualNodeId} 的 ${allPaths.length} 條路徑:`, allPaths);
              highlightPath(allPaths);
            } else {
              console.log(`找不到從起點到 ${actualNodeId} 的路徑`);
              console.log("可能的原因：");
              console.log("1. 節點 ID 不匹配");
              console.log("2. 起點不存在");
              console.log("3. 圖形不連通");
              clearPathHighlight();
            }
            
            showNodeInfo(actualNodeId, nodeLabel);
          });
        });
      }

      // --- 顯示節點資訊 ---
      function showNodeInfo(nodeId, nodeLabel) {
        console.log("尋找節點:", nodeId, "標籤:", nodeLabel, "在 nodeDetails 中:", state.nodeDetails);
        // 先嘗試用 ID 匹配
        let nodeDetail = state.nodeDetails.find(n => n.id === nodeId);
        // 如果找不到，嘗試用標籤匹配
        if (!nodeDetail) {
          nodeDetail = state.nodeDetails.find(n => n.label === nodeLabel);
          console.log("用標籤匹配找到的 nodeDetail:", nodeDetail);
        } else {
          console.log("用 ID 匹配找到的 nodeDetail:", nodeDetail);
        }
        if (nodeDetail) {
          showCustomModal(nodeDetail);
        } else {
          // 如果找不到詳細資訊，顯示基本資訊
          showCustomModal({
            id: nodeId,
            label: nodeLabel,
            attribute: "",
            status: "",
            statusText: "未知",
            prompt: "此節點沒有詳細資訊。",
            color: "white"
          });
        }
      }

      // --- 複製 Prompt 到剪貼簿 ---
      async function copyPromptToClipboard(promptText) {
        try {
          // 使用現代的 Clipboard API
          if (navigator.clipboard && window.isSecureContext) {
            await navigator.clipboard.writeText(promptText);
            showCopySuccess();
          } else {
            // 降級方案：使用傳統的 document.execCommand
            const textArea = document.createElement('textarea');
            textArea.value = promptText;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            const successful = document.execCommand('copy');
            document.body.removeChild(textArea);
            
            if (successful) {
              showCopySuccess();
            } else {
              showCopyError();
            }
          }
        } catch (err) {
          console.error('複製失敗:', err);
          showCopyError();
        }
      }

      // 顯示複製成功回饋
      function showCopySuccess() {
        // 找到所有複製按鈕並更新狀態
        const copyButtons = document.querySelectorAll('.copy-button');
        copyButtons.forEach(button => {
          const originalText = button.textContent;
          button.classList.add('copied');
          button.textContent = '已複製';
          
          // 2秒後恢復原狀
          setTimeout(() => {
            button.classList.remove('copied');
            button.textContent = originalText;
          }, 2000);
        });
      }

      // 顯示複製錯誤回饋
      function showCopyError() {
        const copyButtons = document.querySelectorAll('.copy-button');
        copyButtons.forEach(button => {
          const originalText = button.textContent;
          button.style.background = '#dc3545';
          button.textContent = '複製失敗';
          
          // 2秒後恢復原狀
          setTimeout(() => {
            button.style.background = '';
            button.textContent = originalText;
          }, 2000);
        });
      }

      // --- 自定義彈出視窗 ---
      function showCustomModal(nodeDetail) {
        console.log("顯示節點詳情:", nodeDetail);
        const modal = document.getElementById('nodeModal');
        const title = document.getElementById('modalTitle');
        const content = document.getElementById('modalContent');
        
        title.textContent = `${nodeDetail.label}`;
        content.innerHTML = `
          <div class="node-info">
            <div class="info-row">
              <span class="info-label">ID:</span>
              <span class="info-value">${nodeDetail.id}</span>
            </div>
            ${nodeDetail.attribute ? `
            <div class="info-row">
              <span class="info-label">屬性:</span>
              <span class="info-value">${nodeDetail.attribute}</span>
            </div>
            ` : ''}
            <div class="info-row">
              <span class="info-label">提示:</span>
              <div class="info-prompt">
                ${nodeDetail.prompt}
                <button class="copy-button" onclick="copyPromptToClipboard('${nodeDetail.prompt.replace(/'/g, "\\'")}')">複製</button>
              </div>
            </div>
          </div>
        `;
        
        modal.style.display = 'block';
      }

      // --- 彈出視窗事件處理 ---
      document.querySelector('.close').onclick = function() {
        document.getElementById('nodeModal').style.display = 'none';
      }

      window.onclick = function(event) {
        const modal = document.getElementById('nodeModal');
        if (event.target == modal) {
          modal.style.display = 'none';
        }
      }

      // 按 ESC 鍵關閉彈出視窗
      document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape') {
          document.getElementById('nodeModal').style.display = 'none';
        }
      });

      // --- 搜尋功能 ---
      
      // 高亮搜尋關鍵字
      function highlightText(text, keyword) {
        if (!keyword) return text;
        const regex = new RegExp(`(${keyword})`, 'gi');
        return text.replace(regex, '<span class="search-result-highlight">$1</span>');
      }

      // 搜尋節點
      function searchNodes(keyword) {
        if (!keyword || keyword.length < 1) {
          searchResults.classList.remove('show');
          return;
        }

        const results = state.nodeDetails.filter(node => {
          const searchText = `${node.label} ${node.prompt} ${node.attribute}`.toLowerCase();
          return searchText.includes(keyword.toLowerCase());
        });

        displaySearchResults(results, keyword);
      }

      // 顯示搜尋結果
      function displaySearchResults(results, keyword) {
        if (results.length === 0) {
          searchResults.innerHTML = '<div class="no-results">找不到符合條件的節點</div>';
        } else {
          searchResults.innerHTML = results.map(node => `
            <div class="search-result-item" data-node-id="${node.id}">
              <div class="search-result-title">${highlightText(node.label, keyword)}</div>
              <div class="search-result-subtitle">${highlightText(node.prompt.substring(0, 100) + (node.prompt.length > 100 ? '...' : ''), keyword)}</div>
            </div>
          `).join('');
        }
        searchResults.classList.add('show');
      }

      // 處理搜尋結果點擊
      function handleSearchResultClick(nodeId) {
        console.log("=== 搜尋結果點擊調試 ===");
        console.log("點擊的節點 ID:", nodeId);
        
        // 找到對應的節點並觸發點擊
        const svg = zoomInner.querySelector('svg');
        if (!svg) {
          console.log("找不到 SVG 元素");
          return;
        }

        // 通過節點標籤找到對應的 SVG 節點
        const nodeDetail = state.nodeDetails.find(n => n.id === nodeId);
        if (!nodeDetail) {
          console.log("找不到節點詳細資訊");
          return;
        }

        console.log("節點詳細資訊:", nodeDetail);
        
        // 通過標籤文字找到對應的 SVG 節點
        const allNodes = svg.querySelectorAll('g.node');
        let nodeElement = null;
        
        for (const node of allNodes) {
          const textElement = node.querySelector('text');
          if (textElement && textElement.textContent === nodeDetail.label) {
            nodeElement = node;
            break;
          }
        }

        console.log("找到的節點元素:", nodeElement);
        console.log("節點元素 ID:", nodeElement ? nodeElement.id : "無");
        
        if (nodeElement) {
          console.log("觸發節點點擊事件");
          // 模擬節點點擊事件
          const clickEvent = new MouseEvent('click', {
            bubbles: true,
            cancelable: true,
            view: window
          });
          nodeElement.dispatchEvent(clickEvent);
          
          // 隱藏搜尋結果
          searchResults.classList.remove('show');
          searchInput.value = '';
        } else {
          console.log("找不到對應的節點元素，直接顯示節點資訊");
          // 如果找不到節點，直接調用 showNodeInfo
          showNodeInfo(nodeDetail.id, nodeDetail.label);
          // 隱藏搜尋結果
          searchResults.classList.remove('show');
          searchInput.value = '';
        }
      }

      // 搜尋輸入事件監聽
      if (searchInput) {
        let searchTimeout;
        searchInput.addEventListener('input', function(e) {
          clearTimeout(searchTimeout);
          searchTimeout = setTimeout(() => {
            searchNodes(e.target.value);
          }, 150); // 150ms 延遲，避免過於頻繁的搜尋
        });

        // 點擊搜尋結果
        searchResults.addEventListener('click', function(e) {
          console.log("搜尋結果被點擊:", e.target);
          const resultItem = e.target.closest('.search-result-item');
          console.log("找到的結果項目:", resultItem);
          if (resultItem) {
            const nodeId = resultItem.dataset.nodeId;
            console.log("節點 ID:", nodeId);
            handleSearchResultClick(nodeId);
          } else {
            console.log("沒有找到結果項目");
          }
        });

        // 點擊外部關閉搜尋結果
        document.addEventListener('click', function(e) {
          if (!searchInput.contains(e.target) && !searchResults.contains(e.target)) {
            searchResults.classList.remove('show');
          }
        });
      }

      // --- 載入動畫控制 ---
      function hideLoadingAnimation() {
        const loadingContainer = document.getElementById('loadingContainer');
        if (loadingContainer) {
          loadingContainer.classList.add('hidden');
          // 動畫完成後移除元素
          setTimeout(() => {
            loadingContainer.style.display = 'none';
          }, 500);
        }
      }

      function showLoadingAnimation() {
        const loadingContainer = document.getElementById('loadingContainer');
        if (loadingContainer) {
          loadingContainer.style.display = 'flex';
          loadingContainer.classList.remove('hidden');
        }
      }

      // --- 動態調整頁面大小 ---
      function adjustPageSizeToGraph(graphWidth, graphHeight) {
        // 計算需要的頁面高度
        const header = document.querySelector('.header');
        const headerHeight = header ? header.offsetHeight + 40 : 0; // 40px 是 header 的 margin
        const graphPadding = 40; // graph 容器的 padding
        const bodyPadding = 40; // body 的 padding (20px * 2)
        
        // 智能處理大地圖
        const isLargeGraph = graphWidth > window.innerWidth * 2 || graphHeight > window.innerHeight * 2;
        let minPageHeight;
        
        if (isLargeGraph) {
          // 大地圖：限制頁面高度，讓用戶可以滾動查看
          const maxPageHeight = window.innerHeight * 1.5; // 最大頁面高度為螢幕高度的1.5倍
          const requiredHeight = headerHeight + graphHeight + graphPadding + bodyPadding + 20;
          minPageHeight = Math.min(requiredHeight, maxPageHeight);
          
          // 啟用滾動
          document.body.style.overflowX = 'auto';
          document.body.style.overflowY = 'auto';
        } else {
          // 小地圖：正常處理
          minPageHeight = headerHeight + graphHeight + graphPadding + bodyPadding + 20;
          document.body.style.overflowX = 'hidden';
          document.body.style.overflowY = 'auto';
        }
        
        // 設置頁面高度
        document.body.style.minHeight = minPageHeight + 'px';
        document.body.style.height = 'auto';
        
        console.log(`頁面大小調整: 地圖尺寸 ${graphWidth}x${graphHeight}, 是否大地圖: ${isLargeGraph}, 頁面高度: ${minPageHeight}px`);
      }

      // --- 移除多餘空白 ---
      function removeExcessWhitespace() {
        const graph = document.getElementById('graph');
        const header = document.querySelector('.header');
        
        if (!graph || !header) return;
        
        // 計算實際需要的頁面高度
        const headerHeight = header.offsetHeight + 40; // header + margin
        const graphHeight = graph.offsetHeight;
        const bodyPadding = 40; // body padding
        const requiredHeight = headerHeight + graphHeight + bodyPadding + 20; // 20px 緩衝
        
        // 設置精確的頁面高度
        document.body.style.minHeight = requiredHeight + 'px';
        document.body.style.height = requiredHeight + 'px';
        
        // 確保沒有多餘的底部空白
        const currentScrollHeight = document.body.scrollHeight;
        if (currentScrollHeight > requiredHeight + 100) {
          // 如果還有太多空白，進一步調整
          document.body.style.height = (requiredHeight - 50) + 'px';
        }
        
        console.log(`空白移除: 需要高度 ${requiredHeight}px, 當前高度 ${currentScrollHeight}px`);
      }

      // --- 取得 DOT 並渲染（含 log） ---
      function applyBackgroundFromConfig(url) {
        if (typeof url === 'string' && url.trim()) {
          state.backgroundImageUrl = url.trim();
          // 覆寫背景圖（若提供的是完整 URL）
          const bg = `url("${state.backgroundImageUrl}")`;
          zoomInner.style.backgroundImage = bg;
        }
      }

      // 顯示載入動畫
      showLoadingAnimation();

      google.script.run
        .withSuccessHandler(function (data) {
          console.log("Graphviz 資料：", data);
          state.dot = data.dot;
          state.nodeDetails = data.nodeDetails;
          state.edgeDetails = data.edgeDetails;
          state.adjacencyList = data.adjacencyList;
          applyBackgroundFromConfig(data.backgroundImageUrl);
          
          // 渲染完成後隱藏載入動畫
          renderGraph().then(() => {
            hideLoadingAnimation();
            // 延遲一點時間確保 DOM 完全渲染後再調整
            setTimeout(() => {
              removeExcessWhitespace();
            }, 100);
          });
        })
        .withFailureHandler(function (err) {
          console.error('取得資料失敗：', err);
          const msg = (err && err.message) ? err.message : '載入資料時發生未知錯誤。';
          graph.innerHTML = `<div style="padding:16px;color:#b00020">${msg}</div>`;
          // 即使失敗也要隱藏載入動畫
          hideLoadingAnimation();
        })
        .getGraphData();
    </script>
  </body>
</html>
