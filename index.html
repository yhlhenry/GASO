<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>GAS Graphviz</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- viz.js + worker (full.render.js includes all engines) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/viz.js/2.1.2/viz.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/viz.js/2.1.2/full.render.js"></script>

    <style>
      :root { color-scheme: light dark; }
      html, body { 
        font-family: 'Times New Roman', 'Georgia', serif; 
        margin: 0; 
        padding: 0; 
        background: #f4f1e8; 
        background-image: 
          radial-gradient(circle at 20% 50%, rgba(139, 69, 19, 0.1) 0%, transparent 50%),
          radial-gradient(circle at 80% 20%, rgba(160, 82, 45, 0.1) 0%, transparent 50%),
          radial-gradient(circle at 40% 80%, rgba(101, 67, 33, 0.1) 0%, transparent 50%);
        height: 100vh;
        width: 100vw;
        overflow: hidden; /* å®Œå…¨ç§»é™¤æ²è»¸ */
        box-sizing: border-box;
        position: fixed; /* å›ºå®šå®šä½ï¼Œé˜²æ­¢æ²å‹• */
      }
      
      .header {
        background: #faf8f3;
        border: 3px solid #8b4513;
        border-radius: 8px;
        padding: 15px 25px; /* æ¸›å°‘ä¸Šä¸‹ padding */
        margin: 10px; /* æ¸›å°‘ margin */
        box-shadow: 
          0 4px 8px rgba(0, 0, 0, 0.2),
          inset 0 1px 0 rgba(255, 255, 255, 0.3);
        position: absolute; /* çµ•å°å®šä½ */
        top: 0;
        left: 0;
        right: 0;
        z-index: 1000; /* ç¢ºä¿åœ¨åœ°åœ–ä¸Šæ–¹ */
        display: flex;
        align-items: center;
        justify-content: space-between;
        flex-wrap: wrap;
        gap: 20px;
        padding-right: 90px; /* ç‚ºæ§åˆ¶é¢æ¿æŒ‰éˆ•ç•™å‡ºç©ºé–“ */
      }
      
      .header::before {
        content: '';
        position: absolute;
        top: -2px;
        left: -2px;
        right: -2px;
        bottom: -2px;
        background: linear-gradient(45deg, #8b4513, #a0522d, #8b4513);
        border-radius: 8px;
        z-index: -1;
      }
      
      h2 { 
        margin: 0; 
        font-size: 2.2rem;
        font-weight: bold;
        color: #8b4513;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        letter-spacing: 1px;
        font-family: 'Times New Roman', serif;
      }
      
      .title-section {
        flex: 1;
        min-width: 300px;
      }
      
      .subtitle {
        color: #654321;
        font-size: 1rem;
        font-weight: normal;
        font-style: italic;
        margin-top: 5px;
      }
      #graph { 
        position: fixed; /* å›ºå®šå®šä½ï¼Œå…¨è¢å¹•è¦†è“‹ */
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        overflow: hidden; /* å®Œå…¨éš±è—æ²è»¸ */
        border: none; /* ç§»é™¤é‚Šæ¡† */
        background: #faf8f3; 
        cursor: grab;
        user-select: none;
        z-index: 1; /* ç¢ºä¿åœ¨åœ°åœ–å±¤ */
        padding-top: 80px; /* ç‚º header ç•™å‡ºç©ºé–“ */
        box-sizing: border-box;
      }
      
      #graph.dragging {
        cursor: grabbing;
      }
      
      #graph.drag-mode {
        cursor: grab;
      }
      
      #graph.drag-mode.dragging {
        cursor: grabbing;
      }
      
      #zoomInner { 
        transform-origin: 0 0; 
        display: inline-block; 
        position: relative;
        transition: transform 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      }
      
      #zoomInner.dragging {
        transition: none;
      }
      
      #zoomInner.zooming {
        transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      }
      #zoomInner::before { 
        content: ''; 
        position: absolute; 
        top: -100px; 
        left: -100px; 
        right: -100px; 
        bottom: -100px; 
        background-image: url("https://raw.githubusercontent.com/yhlhenry/GASO/main/image/World_Map_By_ChatGPT_Fixed_By_Gemini.png"); 
        background-repeat: no-repeat; 
        background-position: center center; 
        background-size: cover; 
        opacity: 0.3; 
        z-index: -1; 
      }
      #zoomInner svg { background: transparent !important; position: relative; z-index: 1; }
      #zoomInner svg polygon[fill="#ffffff"] { fill: transparent !important; }
      
      /* ç¯€é»åŠé€æ˜æ¼¸å±¤æ•ˆæœ */
      #zoomInner svg g.node rect,
      #zoomInner svg g.node ellipse,
      #zoomInner svg g.node polygon {
        fill: url(#nodeGradient) !important;
        stroke: none !important;
      }
      
      #zoomInner svg g.node text {
        fill: white !important;
        font-weight: bold !important;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5) !important;
      }
      .controls { display: flex; align-items: center; gap: .5rem; flex-wrap: wrap; margin: .5rem 0 1rem; }
      .controls input[type="range"] { width: 150px; }
      .controls button, .controls select { padding: .35rem .6rem; border: 1px solid #bbb; background: #f8f8f8; border-radius: 6px; cursor: pointer; }
      .controls button:active { transform: translateY(1px); }
      label { display: inline-flex; align-items: center; gap: .35rem; }
      .muted { color: #666; font-size: .9em; }
      .row { display: flex; gap: .75rem; align-items: center; flex-wrap: wrap; }

      /* å½ˆå‡ºè¦–çª—æ¨£å¼ */
      .modal {
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.5);
        backdrop-filter: blur(2px);
      }

      .modal-content {
        background-color: #fefefe;
        margin: 10% auto;
        padding: 25px;
        border: 1px solid #888;
        width: 90%;
        max-width: 500px;
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        position: relative;
        animation: modalSlideIn 0.3s ease-out;
      }

      @keyframes modalSlideIn {
        from {
          opacity: 0;
          transform: translateY(-50px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .close {
        color: #aaa;
        float: right;
        font-size: 28px;
        font-weight: bold;
        cursor: pointer;
        position: absolute;
        right: 15px;
        top: 15px;
        line-height: 1;
      }

      .close:hover {
        color: #000;
      }

      /* ç¯€é»è³‡è¨Šæ¨£å¼ */
      .node-info {
        margin-top: 15px;
      }

      .info-row {
        display: flex;
        margin-bottom: 12px;
        align-items: flex-start;
      }

      .info-label {
        font-weight: bold;
        color: #333;
        min-width: 60px;
        margin-right: 10px;
      }

      .info-value {
        color: #666;
        flex: 1;
      }

      .info-prompt {
        color: #666;
        flex: 1;
        line-height: 1.5;
        background: #f8f9fa;
        padding: 10px 50px 10px 10px; /* å³é‚Šå¢åŠ å…§é‚Šè·é¿å…è¢«æŒ‰éˆ•é®ä½ */
        border-radius: 6px;
        border-left: 3px solid #007bff;
        position: relative;
        min-height: 40px; /* ç¢ºä¿æœ‰è¶³å¤ é«˜åº¦å®¹ç´æŒ‰éˆ• */
      }

      .copy-button {
        position: absolute;
        top: 6px;
        right: 6px;
        background: #007bff;
        color: white;
        border: none;
        border-radius: 4px;
        padding: 6px 10px;
        font-size: 11px;
        cursor: pointer;
        transition: all 0.2s ease;
        z-index: 10; /* ç¢ºä¿æŒ‰éˆ•åœ¨æœ€ä¸Šå±¤ */
        box-shadow: 0 1px 3px rgba(0,0,0,0.2); /* æ·»åŠ é™°å½±è®“æŒ‰éˆ•æ›´æ˜é¡¯ */
      }

      .copy-button:hover {
        background: #0056b3;
        transform: scale(1.05);
      }

      .copy-button:active {
        transform: scale(0.95);
      }

      .copy-button.copied {
        background: #28a745;
      }

      .copy-button.copied::after {
        content: " âœ“";
      }

      /* ç‹€æ…‹æ¨™ç±¤æ¨£å¼ */
      .status-todo {
        background: #e9ecef;
        color: #495057;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 0.85em;
      }

      .status-inprogress {
        background: #fff3cd;
        color: #856404;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 0.85em;
      }

      .status-done {
        background: #d4edda;
        color: #155724;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 0.85em;
      }

      .status- {
        background: #f8d7da;
        color: #721c24;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 0.85em;
      }

      /* æœå°‹åŠŸèƒ½æ¨£å¼ */
      .search-container {
        margin: 0;
        position: relative;
        flex: 1;
        max-width: 400px;
      }

      .search-box {
        position: relative;
        width: 100%;
      }

      .search-box::before {
        content: 'ğŸ”';
        position: absolute;
        right: 12px;
        top: 50%;
        transform: translateY(-50%);
        font-size: 16px;
        color: #8b7355;
        pointer-events: none;
        z-index: 1;
      }

      #searchInput {
        width: 100%;
        padding: 12px 40px 12px 16px; /* å³é‚Šç•™å‡ºç©ºé–“çµ¦æ”¾å¤§é¡åœ–ç¤º */
        border: 2px solid #8b4513;
        border-radius: 4px;
        font-size: 16px;
        box-sizing: border-box;
        transition: all 0.3s ease;
        background: #faf8f3;
        color: #8b4513;
        font-family: 'Times New Roman', serif;
        box-shadow: 
          inset 0 2px 4px rgba(0, 0, 0, 0.1),
          0 2px 4px rgba(0, 0, 0, 0.2);
      }

      #searchInput:focus {
        outline: none;
        border-color: #a0522d;
        box-shadow: 
          inset 0 2px 4px rgba(0, 0, 0, 0.1),
          0 0 0 3px rgba(160, 82, 45, 0.3),
          0 2px 4px rgba(0, 0, 0, 0.2);
        background: #fffef7;
      }

      #searchInput::placeholder {
        color: #8b7355;
        font-weight: normal;
        font-style: italic;
      }

      .search-results {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background: white;
        border: 1px solid #ddd;
        border-top: none;
        border-radius: 0 0 8px 8px;
        max-height: 300px;
        overflow-y: auto;
        z-index: 1000;
        display: none;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      }

      .search-results.show {
        display: block;
      }

      .search-result-item {
        padding: 12px 16px;
        cursor: pointer;
        border-bottom: 1px solid #f0f0f0;
        transition: background-color 0.2s ease;
      }

      .search-result-item:hover {
        background-color: #f8f9fa;
      }

      .search-result-item:last-child {
        border-bottom: none;
      }

      .search-result-title {
        font-weight: bold;
        color: #333;
        margin-bottom: 4px;
      }

      .search-result-subtitle {
        font-size: 0.9em;
        color: #666;
        line-height: 1.4;
      }

      .search-result-highlight {
        background-color: #fff3cd;
        padding: 1px 2px;
        border-radius: 2px;
      }

      .no-results {
        padding: 16px;
        text-align: center;
        color: #666;
        font-style: italic;
      }

      /* ç¯€é»å½¢ç‹€é¸æ“‡å™¨æ¨£å¼å„ªåŒ– */
      #nodeShapeSelect {
        min-width: 120px;
      }

      /* å´é‚Šé¢æ¿æ¨£å¼ */
      .sidebar {
        position: fixed;
        top: 0;
        right: -350px;
        width: 350px;
        height: 100vh;
        background: #faf8f3;
        border-left: 3px solid #8b4513;
        box-shadow: 
          -4px 0 12px rgba(0, 0, 0, 0.3),
          inset 1px 0 0 rgba(255, 255, 255, 0.2);
        transition: right 0.3s ease;
        z-index: 1001; /* ç¢ºä¿åœ¨ header ä¸Šæ–¹ */
        overflow-y: auto;
        padding: 20px;
        box-sizing: border-box;
      }

      .sidebar.open {
        right: 0;
      }

      .sidebar-toggle {
        position: fixed;
        top: 20px;
        right: 20px;
        background: #8b4513;
        color: #faf8f3;
        border: 2px solid #654321;
        border-radius: 8px;
        width: 50px;
        height: 50px;
        font-size: 18px;
        cursor: pointer;
        box-shadow: 
          0 4px 8px rgba(0, 0, 0, 0.3),
          inset 0 1px 0 rgba(255, 255, 255, 0.2);
        transition: all 0.3s ease;
        z-index: 1001;
        font-family: 'Times New Roman', serif;
        font-weight: bold;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
      }

      .sidebar-toggle:hover {
        background: #a0522d;
        border-color: #8b4513;
        transform: scale(1.05);
        box-shadow: 
          0 6px 12px rgba(0, 0, 0, 0.4),
          inset 0 1px 0 rgba(255, 255, 255, 0.3);
      }

      .sidebar-toggle.open {
        right: 20px;
        background: #654321;
        border-color: #8b4513;
      }

      .sidebar-toggle.open:hover {
        background: #8b4513;
        border-color: #654321;
      }

      .sidebar-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 2px solid #dee2e6;
      }

      .sidebar-title {
        font-size: 18px;
        font-weight: bold;
        color: #333;
        margin: 0;
      }

      .sidebar-close {
        background: none;
        border: none;
        font-size: 24px;
        color: #666;
        cursor: pointer;
        padding: 0;
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .sidebar-close:hover {
        color: #333;
      }

      .control-group {
        margin-bottom: 25px;
        padding: 15px;
        background: #f4f1e8;
        border: 2px solid #8b4513;
        border-radius: 8px;
        box-shadow: 
          0 2px 4px rgba(0, 0, 0, 0.2),
          inset 0 1px 0 rgba(255, 255, 255, 0.3);
      }

      .control-group-title {
        font-size: 14px;
        font-weight: bold;
        color: #8b4513;
        margin-bottom: 12px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        font-family: 'Times New Roman', serif;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.1);
      }

      .control-item {
        margin-bottom: 15px;
      }

      .control-item:last-child {
        margin-bottom: 0;
      }

      .control-item label {
        display: block;
        margin-bottom: 5px;
        font-size: 13px;
        color: #654321;
        font-weight: 500;
        font-family: 'Times New Roman', serif;
      }

      .control-item input[type="range"] {
        width: 100%;
        margin: 5px 0;
      }

      .control-item select {
        width: 100%;
        padding: 8px 12px;
        border: 2px solid #8b4513;
        border-radius: 4px;
        background: #faf8f3;
        font-size: 14px;
        color: #8b4513;
        font-family: 'Times New Roman', serif;
        box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1);
      }

      .control-item button {
        width: 100%;
        padding: 8px 12px;
        border: 2px solid #8b4513;
        border-radius: 4px;
        background: #faf8f3;
        cursor: pointer;
        font-size: 14px;
        color: #8b4513;
        font-family: 'Times New Roman', serif;
        font-weight: bold;
        transition: all 0.2s ease;
        box-shadow: 
          0 2px 4px rgba(0, 0, 0, 0.2),
          inset 0 1px 0 rgba(255, 255, 255, 0.3);
      }

      .control-item button:hover {
        background: #a0522d;
        color: #faf8f3;
        border-color: #654321;
        box-shadow: 
          0 3px 6px rgba(0, 0, 0, 0.3),
          inset 0 1px 0 rgba(255, 255, 255, 0.2);
      }

      .control-item button.danger {
        background: #8b4513;
        color: #faf8f3;
        border-color: #654321;
      }

      .control-item button.danger:hover {
        background: #654321;
        border-color: #8b4513;
      }

      .value-display {
        font-size: 12px;
        color: #8b4513;
        font-weight: bold;
        margin-left: 10px;
        font-family: 'Times New Roman', serif;
      }

      /* è¼‰å…¥å‹•ç•«æ¨£å¼ */
      .loading-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #f4f1e8;
        background-image: 
          radial-gradient(circle at 20% 50%, rgba(139, 69, 19, 0.1) 0%, transparent 50%),
          radial-gradient(circle at 80% 20%, rgba(160, 82, 45, 0.1) 0%, transparent 50%),
          radial-gradient(circle at 40% 80%, rgba(101, 67, 33, 0.1) 0%, transparent 50%);
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        transition: opacity 0.5s ease-out;
      }

      .loading-container.hidden {
        opacity: 0;
        pointer-events: none;
      }

      .loading-spinner {
        width: 80px;
        height: 80px;
        border: 6px solid #8b4513;
        border-top: 6px solid #a0522d;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-bottom: 30px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      }

      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }

      .loading-text {
        font-family: 'Times New Roman', serif;
        font-size: 24px;
        font-weight: bold;
        color: #8b4513;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        margin-bottom: 20px;
        animation: pulse 2s ease-in-out infinite;
      }

      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
      }

      .loading-dots {
        display: flex;
        gap: 8px;
        margin-top: 10px;
      }

      .loading-dot {
        width: 12px;
        height: 12px;
        background: #8b4513;
        border-radius: 50%;
        animation: bounce 1.4s ease-in-out infinite both;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .loading-dot:nth-child(1) { animation-delay: -0.32s; }
      .loading-dot:nth-child(2) { animation-delay: -0.16s; }
      .loading-dot:nth-child(3) { animation-delay: 0s; }

      @keyframes bounce {
        0%, 80%, 100% {
          transform: scale(0);
        }
        40% {
          transform: scale(1);
        }
      }

      .loading-progress {
        width: 300px;
        height: 6px;
        background: rgba(139, 69, 19, 0.2);
        border-radius: 3px;
        overflow: hidden;
        margin-top: 20px;
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2);
      }

      .loading-progress-bar {
        height: 100%;
        background: linear-gradient(90deg, #8b4513, #a0522d, #8b4513);
        background-size: 200% 100%;
        animation: progressMove 2s ease-in-out infinite;
        border-radius: 3px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      }

      @keyframes progressMove {
        0% { 
          width: 0%;
          background-position: 0% 50%;
        }
        50% { 
          width: 70%;
          background-position: 100% 50%;
        }
        100% { 
          width: 100%;
          background-position: 0% 50%;
        }
      }

      .loading-subtitle {
        font-family: 'Times New Roman', serif;
        font-size: 16px;
        color: #654321;
        font-style: italic;
        margin-top: 15px;
        opacity: 0.8;
      }

      /* å€‹äººåŒ–è³‡è¨Šè¡¨å–®æ¨£å¼ */
      .custom-info-form {
        margin-top: 20px;
      }

      .form-group {
        margin-bottom: 25px;
      }

      .form-group label {
        display: block;
        margin-bottom: 8px;
        font-weight: bold;
        color: #8b4513;
        font-size: 16px;
        font-family: 'Times New Roman', serif;
      }

      .input-group {
        position: relative;
      }

      .form-select, .form-input {
        width: 100%;
        padding: 12px 16px;
        border: 2px solid #8b4513;
        border-radius: 6px;
        font-size: 14px;
        font-family: 'Times New Roman', serif;
        background: #faf8f3;
        color: #8b4513;
        box-sizing: border-box;
        transition: all 0.3s ease;
      }

      .form-select:focus, .form-input:focus {
        outline: none;
        border-color: #a0522d;
        box-shadow: 0 0 0 3px rgba(160, 82, 45, 0.3);
        background: #fffef7;
      }

      .form-actions {
        display: flex;
        gap: 15px;
        justify-content: center;
        margin-top: 30px;
      }

      .btn-primary, .btn-secondary {
        padding: 12px 24px;
        border: 2px solid;
        border-radius: 6px;
        font-size: 14px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
        font-family: 'Times New Roman', serif;
        min-width: 100px;
      }

      .btn-primary {
        background: #8b4513;
        color: #faf8f3;
        border-color: #654321;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .btn-primary:hover {
        background: #a0522d;
        border-color: #8b4513;
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      }

      .btn-secondary {
        background: #faf8f3;
        color: #8b4513;
        border-color: #8b4513;
      }

      .btn-secondary:hover {
        background: #8b4513;
        color: #faf8f3;
        transform: translateY(-1px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      }

      /* Debug è³‡è¨Šæ¨£å¼ */
      .debug-info {
        position: fixed;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.8);
        color: #00ff00;
        padding: 10px;
        border-radius: 5px;
        font-family: monospace;
        font-size: 12px;
        z-index: 9999;
        border: 1px solid #00ff00;
      }
      .debug-info div {
        margin: 2px 0;
      }

      /* éŸ¿æ‡‰å¼è¨­è¨ˆå„ªåŒ– */
      @media (max-width: 768px) {
        .header {
          padding: 10px 15px; /* æ¸›å°‘æ‰‹æ©Ÿç‰ˆçš„ padding */
          margin: 5px; /* æ¸›å°‘æ‰‹æ©Ÿç‰ˆçš„ margin */
        }
        
        .sidebar {
          width: 100%;
          right: -100%;
        }

        .sidebar.open {
          right: 0;
        }

        .sidebar-toggle.open {
          right: 20px;
        }

        .controls.row {
          flex-direction: column;
          align-items: flex-start;
        }
        
        .controls.row label {
          margin-left: 0 !important;
          margin-top: 0.5rem;
        }
        
        #nodeShapeSelect {
          min-width: 100%;
        }

        .loading-text {
          font-size: 20px;
        }

        .loading-progress {
          width: 250px;
        }
        
        /* æ‰‹æ©Ÿç‰ˆåœ°åœ–å®¹å™¨èª¿æ•´ */
        #graph {
          padding-top: 60px; /* æ¸›å°‘æ‰‹æ©Ÿç‰ˆçš„ header ç©ºé–“ */
        }
      }
    </style>
  </head>
  <body>
    <!-- è¼‰å…¥å‹•ç•« -->
    <div class="loading-container" id="loadingContainer">
      <div class="loading-spinner"></div>
      <div class="loading-text">æ­£åœ¨è¼‰å…¥å­¸ç¿’åœ°åœ–</div>
      <div class="loading-dots">
        <div class="loading-dot"></div>
        <div class="loading-dot"></div>
        <div class="loading-dot"></div>
      </div>
      <div class="loading-progress">
        <div class="loading-progress-bar"></div>
      </div>
      <div class="loading-subtitle">æ¢ç´¢ Google Apps Script çš„ç„¡é™å¯èƒ½</div>
    </div>

    <!-- Debug è³‡è¨Šé¡¯ç¤º -->
    <div class="debug-info" id="debugInfo">
      <div>è¢å¹•: <span id="screenWidth">-</span> x <span id="screenHeight">-</span></div>
      <div>å®¹å™¨: <span id="containerWidth">-</span> x <span id="containerHeight">-</span></div>
      <div>SVG: <span id="svgWidth">-</span> x <span id="svgHeight">-</span></div>
    </div>

    <!-- é é¢æ¨™é¡Œå’Œæœå°‹å€åŸŸ -->
    <div class="header">
      <div class="title-section">
        <h2>Google Apps Script Odyssey</h2>
        <div class="subtitle">æ¢ç´¢ Google Apps Script å­¸ç¿’è·¯å¾‘çš„è¦–è¦ºåŒ–åœ°åœ–</div>
      </div>
      
      <!-- æœå°‹åŠŸèƒ½ -->
      <div class="search-container">
        <div class="search-box">
          <input type="text" id="searchInput" placeholder="æœå°‹ç¯€é»..." autocomplete="off" />
          <div id="searchResults" class="search-results"></div>
        </div>
      </div>
    </div>

    <!-- å´é‚Šé¢æ¿åˆ‡æ›æŒ‰éˆ• -->
    <button class="sidebar-toggle" id="sidebarToggle">âš™ï¸</button>

    <!-- å´é‚Šæ§åˆ¶é¢æ¿ -->
    <div class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <h3 class="sidebar-title">æ§åˆ¶é¢æ¿</h3>
        <button class="sidebar-close" id="sidebarClose">Ã—</button>
      </div>

      <!-- ç¸®æ”¾æ§åˆ¶çµ„ -->
      <div class="control-group">
        <div class="control-group-title">ç¸®æ”¾æ§åˆ¶</div>
        <div class="control-item">
          <label>ç¸®æ”¾æ¯”ä¾‹</label>
          <input id="zoomRange" type="range" min="25" max="400" step="5" value="100" />
          <span id="zoomLabel" class="value-display">100%</span>
        </div>
        <div class="control-item">
          <button id="zoomOut">ç¸®å° (âˆ’)</button>
        </div>
        <div class="control-item">
          <button id="zoomIn">æ”¾å¤§ (ï¼‹)</button>
        </div>
        <div class="control-item">
          <button id="fitWidth">è§€çœ‹å…¨åœ°åœ–</button>
        </div>
        <div class="control-item">
          <button id="goToStart">å›åˆ°èµ·é»</button>
        </div>
        <div class="control-item">
          <button id="resetZoom">é‡è¨­ç¸®æ”¾</button>
        </div>
        <div class="control-item">
          <small style="color: #666;">(Ctrl+æ»¾è¼ªå¯ç¸®æ”¾)</small>
        </div>
      </div>

      <!-- ç‰ˆé¢é…ç½®æ§åˆ¶çµ„ -->
      <div class="control-group">
        <div class="control-group-title">ç‰ˆé¢é…ç½®</div>
        <div class="control-item">
          <label>Layout å¼•æ“</label>
          <select id="layoutSelect">
            <option value="dot">dotï¼ˆéšå±¤å¼ï¼‰</option>
            <option value="neato" selected>neatoï¼ˆåŠ›å°å‘ï¼‰</option>
            <option value="fdp">fdpï¼ˆåŠ›å°å‘ï¼‰</option>
            <option value="twopi">twopiï¼ˆæ”¾å°„ç‹€ï¼‰</option>
            <option value="circo">circoï¼ˆåœ“ç’°ï¼‰</option>
            <option value="osage">osageï¼ˆå¢é›†ï¼‰</option>
            <option value="patchwork">patchworkï¼ˆæ¨¹åœ–ï¼‰</option>
          </select>
        </div>
        <div class="control-item">
          <label>æ–¹å‘ (rankdir)</label>
          <select id="rankdirSelect">
            <option value="TB">TBï¼ˆä¸Šâ†’ä¸‹ï¼‰</option>
            <option value="LR">LRï¼ˆå·¦â†’å³ï¼‰</option>
            <option value="BT">BTï¼ˆä¸‹â†’ä¸Šï¼‰</option>
            <option value="RL">RLï¼ˆå³â†’å·¦ï¼‰</option>
          </select>
        </div>
        <div class="control-item">
          <label>é‚Šç·šæ¨£å¼</label>
          <select id="splinesSelect">
            <option value="curved">å½æ›²é‚Š</option>
            <option value="line">ç›´ç·šé‚Š</option>
          </select>
        </div>
        <div class="control-item">
          <label>ç¯€é»å½¢ç‹€</label>
          <select id="nodeShapeSelect">
            <option value="ellipse">æ©¢åœ“å½¢</option>
            <option value="box" selected>çŸ©å½¢</option>
            <option value="diamond">è±å½¢</option>
            <option value="triangle">ä¸‰è§’å½¢</option>
            <option value="circle">åœ“å½¢</option>
            <option value="hexagon">å…­è§’å½¢</option>
            <option value="octagon">å…«è§’å½¢</option>
            <option value="star">æ˜Ÿå½¢</option>
            <option value="house">æˆ¿å­å½¢</option>
            <option value="invhouse">å€’æˆ¿å­å½¢</option>
            <option value="trapezium">æ¢¯å½¢</option>
            <option value="parallelogram">å¹³è¡Œå››é‚Šå½¢</option>
          </select>
        </div>
      </div>

      <!-- å­—é«”æ§åˆ¶çµ„ -->
      <div class="control-group">
        <div class="control-group-title">å­—é«”è¨­å®š</div>
        <div class="control-item">
          <label>å­—é«”å¤§å°</label>
          <input id="fontRange" type="range" min="8" max="40" step="1" value="14" />
          <span id="fontLabel" class="value-display">14px</span>
        </div>
        <div class="control-item">
          <button id="fontSmaller">å­—é«”ç¸®å°</button>
        </div>
        <div class="control-item">
          <button id="fontBigger">å­—é«”æ”¾å¤§</button>
        </div>
        <div class="control-item">
          <button id="resetFont">é‡è¨­å­—é«”</button>
        </div>
      </div>

      <!-- è·¯å¾‘æ§åˆ¶çµ„ -->
      <div class="control-group">
        <div class="control-group-title">è·¯å¾‘æ§åˆ¶</div>
        <div class="control-item">
          <button id="clearPathHighlight" class="danger">æ¸…é™¤è·¯å¾‘é«˜äº®</button>
        </div>
      </div>

      <!-- å€‹äººåŒ–è¨­å®šçµ„ -->
      <div class="control-group">
        <div class="control-group-title">å€‹äººåŒ–è¨­å®š</div>
        <div class="control-item">
          <button id="editCustomInfo">ç·¨è¼¯å€‹äººè³‡è¨Š</button>
        </div>
        <div class="control-item">
          <button id="clearCustomInfo" class="danger">æ¸…é™¤å€‹äººè³‡è¨Š</button>
        </div>
        <div class="control-item">
          <small style="color: #666;" id="currentUserInfo">æœªè¨­å®šå€‹äººè³‡è¨Š</small>
        </div>
      </div>

    </div>

    <div id="graph">
      <div id="zoomInner"></div>
    </div>
    

    <!-- å€‹äººåŒ–è³‡è¨Šè¼¸å…¥è¡¨å–® -->
    <div id="customInfoModal" class="modal" style="display: none;">
      <div class="modal-content">
        <span class="close" id="customInfoClose">&times;</span>
        <h3>å€‹äººåŒ–è¨­å®š</h3>
        <div class="custom-info-form">
          <div class="form-group">
            <label for="userRole">æˆ‘æ˜¯è² è²¬</label>
            <div class="input-group">
              <select id="userRoleSelect" class="form-select">
                <option value="">è«‹é¸æ“‡...</option>
                <option value="å°ˆæ¡ˆç®¡ç†">å°ˆæ¡ˆç®¡ç†</option>
                <option value="è³‡æ–™åˆ†æ">è³‡æ–™åˆ†æ</option>
                <option value="è‡ªå‹•åŒ–æµç¨‹">è‡ªå‹•åŒ–æµç¨‹</option>
                <option value="å ±è¡¨è£½ä½œ">å ±è¡¨è£½ä½œ</option>
                <option value="ç³»çµ±æ•´åˆ">ç³»çµ±æ•´åˆ</option>
                <option value="äººåŠ›è³‡æº">äººåŠ›è³‡æº</option>
                <option value="è²¡å‹™ç®¡ç†">è²¡å‹™ç®¡ç†</option>
                <option value="éŠ·å”®æ¥­å‹™">éŠ·å”®æ¥­å‹™</option>
                <option value="è¡ŒéŠ·æ¨å»£">è¡ŒéŠ·æ¨å»£</option>
                <option value="å®¢æˆ¶æœå‹™">å®¢æˆ¶æœå‹™</option>
                <option value="ç‡Ÿé‹ç®¡ç†">ç‡Ÿé‹ç®¡ç†</option>
                <option value="æ•™è‚²è¨“ç·´">æ•™è‚²è¨“ç·´</option>
                <option value="å“è³ªç®¡æ§">å“è³ªç®¡æ§</option>
                <option value="æ¡è³¼ç®¡ç†">æ¡è³¼ç®¡ç†</option>
                <option value="å…¶ä»–">å…¶ä»–</option>
              </select>
              <input type="text" id="userRoleCustom" class="form-input" placeholder="è«‹è¼¸å…¥æ‚¨çš„è·è²¬..." style="display: none;">
            </div>
          </div>
          
          <div class="form-group">
            <label for="userTitle">çš„</label>
            <div class="input-group">
              <select id="userTitleSelect" class="form-select">
                <option value="">è«‹é¸æ“‡...</option>
                <option value="å°ˆæ¡ˆç¶“ç†">å°ˆæ¡ˆç¶“ç†</option>
                <option value="è³‡æ–™åˆ†æå¸«">è³‡æ–™åˆ†æå¸«</option>
                <option value="æ¥­å‹™åˆ†æå¸«">æ¥­å‹™åˆ†æå¸«</option>
                <option value="ç³»çµ±ç®¡ç†å“¡">ç³»çµ±ç®¡ç†å“¡</option>
                <option value="é–‹ç™¼äººå“¡">é–‹ç™¼äººå“¡</option>
                <option value="äººè³‡å°ˆå“¡">äººè³‡å°ˆå“¡</option>
                <option value="è²¡å‹™å°ˆå“¡">è²¡å‹™å°ˆå“¡</option>
                <option value="æœƒè¨ˆå¸«">æœƒè¨ˆå¸«</option>
                <option value="æ¥­å‹™ä»£è¡¨">æ¥­å‹™ä»£è¡¨</option>
                <option value="è¡ŒéŠ·å°ˆå“¡">è¡ŒéŠ·å°ˆå“¡</option>
                <option value="å®¢æœå°ˆå“¡">å®¢æœå°ˆå“¡</option>
                <option value="ç‡Ÿé‹å°ˆå“¡">ç‡Ÿé‹å°ˆå“¡</option>
                <option value="è¨“ç·´å°ˆå“¡">è¨“ç·´å°ˆå“¡</option>
                <option value="å“ç®¡å°ˆå“¡">å“ç®¡å°ˆå“¡</option>
                <option value="æ¡è³¼å°ˆå“¡">æ¡è³¼å°ˆå“¡</option>
                <option value="ä¸»ç®¡">ä¸»ç®¡</option>
                <option value="ç¶“ç†">ç¶“ç†</option>
                <option value="ç¸½ç›£">ç¸½ç›£</option>
                <option value="å…¶ä»–">å…¶ä»–</option>
              </select>
              <input type="text" id="userTitleCustom" class="form-input" placeholder="è«‹è¼¸å…¥æ‚¨çš„è·ä½..." style="display: none;">
            </div>
          </div>
          
          <div class="form-group">
            <label for="gasLevel">æˆ‘å° Google Apps Script ç†Ÿæ‚‰çš„ç¨‹åº¦æ˜¯</label>
            <div class="input-group">
              <select id="gasLevelSelect" class="form-select">
                <option value="">è«‹é¸æ“‡...</option>
                <option value="å®Œå…¨åˆå­¸è€…">å®Œå…¨åˆå­¸è€… - å¾æœªä½¿ç”¨é</option>
                <option value="åˆå­¸è€…">åˆå­¸è€… - çœ‹éä¸€äº›æ•™å­¸ï¼Œä½†æ²’æœ‰å¯¦éš›æ“ä½œ</option>
                <option value="æœ‰åŸºç¤">æœ‰åŸºç¤ - å¯«éç°¡å–®çš„è…³æœ¬ï¼Œäº†è§£åŸºæœ¬æ¦‚å¿µ</option>
                <option value="ä¸­ç´š">ä¸­ç´š - å¯ä»¥ç¨ç«‹å®Œæˆä¸­ç­‰è¤‡é›œåº¦çš„å°ˆæ¡ˆ</option>
                <option value="é«˜ç´š">é«˜ç´š - å¯ä»¥è™•ç†è¤‡é›œçš„æ•´åˆå’Œå„ªåŒ–</option>
                <option value="å°ˆå®¶">å°ˆå®¶ - å¯ä»¥æŒ‡å°ä»–äººä¸¦è§£æ±ºå„ç¨®å•é¡Œ</option>
                <option value="è‡ªè¨‚">è‡ªè¨‚</option>
              </select>
              <input type="text" id="gasLevelCustom" class="form-input" placeholder="è«‹æè¿°æ‚¨çš„ç†Ÿæ‚‰ç¨‹åº¦..." style="display: none;">
            </div>
          </div>
          
          <div class="form-actions">
            <button id="saveCustomInfo" class="btn-primary">å„²å­˜è¨­å®š</button>
            <button id="skipCustomInfo" class="btn-secondary">è·³é</button>
          </div>
        </div>
      </div>
    </div>

    <!-- ç¯€é»è³‡è¨Šå½ˆå‡ºè¦–çª— -->
    <div id="nodeModal" class="modal" style="display: none;">
      <div class="modal-content">
        <span class="close">&times;</span>
        <h3 id="modalTitle">ç¯€é»è³‡è¨Š</h3>
        <div id="modalContent"></div>
      </div>
    </div>

    <script>
      const state = {
        scalePct: 100,
        origW: null,
        origH: null,
        fontSize: 14,
        origFontSize: 14,
        engine: localStorage.getItem("gv_engine") || "neato",
        rankdir: localStorage.getItem("gv_rankdir") || "TB",
        splines: localStorage.getItem("gv_splines") || "line",
        nodeShape: localStorage.getItem("gv_nodeShape") || "box",
        dot: "",
        nodeDetails: [], // å„²å­˜ç¯€é»è©³ç´°è³‡è¨Š
        edgeDetails: [], // å„²å­˜é‚Šè©³ç´°è³‡è¨Š
        adjacencyList: {}, // é„°æ¥è¡¨
        highlightedPath: [], // ç•¶å‰é«˜äº®çš„è·¯å¾‘
        backgroundImageUrl: "", // å¾ä¼ºæœå™¨å‚³ä¾†çš„èƒŒæ™¯åœ– URLï¼ˆå¯è¦†å¯«é è¨­ï¼‰
        // æ‹–æ›³ç›¸é—œç‹€æ…‹
        isDragMode: true, // é è¨­å•Ÿç”¨æ‹–æ›³æ¨¡å¼
        isDragging: false,
        dragStartX: 0,
        dragStartY: 0,
        dragOffsetX: 0,
        dragOffsetY: 0,
        currentTranslateX: 0,
        currentTranslateY: 0,
        // å€‹äººåŒ–è³‡è¨Šç‹€æ…‹
        userInfo: {
          role: "",
          title: "",
          gasLevel: ""
        }
      };

      const $ = (id) => document.getElementById(id);
      const zoomInner = $("zoomInner");
      const graph = $("graph");
      const zoomRange = $("zoomRange");
      const zoomLabel = $("zoomLabel");
      const fontRange = $("fontRange");
      const fontLabel = $("fontLabel");
      const layoutSelect = $("layoutSelect");
      const rankdirSelect = $("rankdirSelect");
      const splinesSelect = $("splinesSelect");
      const nodeShapeSelect = $("nodeShapeSelect");
      const searchInput = $("searchInput");
      const searchResults = $("searchResults");
      const sidebar = $("sidebar");
      const sidebarToggle = $("sidebarToggle");
      const sidebarClose = $("sidebarClose");

      if (layoutSelect) layoutSelect.value = state.engine;
      if (rankdirSelect) rankdirSelect.value = state.rankdir;
      if (splinesSelect) splinesSelect.value = state.splines;
      if (nodeShapeSelect) nodeShapeSelect.value = state.nodeShape;
      
      // åˆå§‹åŒ–æ‹–æ›³æ¨¡å¼ï¼ˆé è¨­å•Ÿç”¨ï¼‰
      graph.classList.add('drag-mode');
      
      // åˆå§‹åŒ–å€‹äººåŒ–è³‡è¨Š
      initCustomInfo();

      // --- å´é‚Šé¢æ¿æ§åˆ¶ ---
      function toggleSidebar() {
        sidebar.classList.toggle('open');
        sidebarToggle.classList.toggle('open');
        adjustGraphMargin();
      }

      function closeSidebar() {
        sidebar.classList.remove('open');
        sidebarToggle.classList.remove('open');
        adjustGraphMargin();
      }

      function adjustGraphMargin() {
        const graph = $("graph");
        if (sidebar.classList.contains('open')) {
          // Google Maps é¢¨æ ¼ï¼šèª¿æ•´åœ°åœ–å®¹å™¨çš„å³é‚Šè·
          if (window.innerWidth > 768) {
            graph.style.width = 'calc(100vw - 350px)';
          }
        } else {
          graph.style.width = '100vw';
        }
      }

      // ç›£è½è¦–çª—å¤§å°è®ŠåŒ–
      window.addEventListener('resize', adjustGraphMargin);

      // å´é‚Šé¢æ¿äº‹ä»¶ç›£è½
      if (sidebarToggle) {
        sidebarToggle.addEventListener('click', toggleSidebar);
      }

      if (sidebarClose) {
        sidebarClose.addEventListener('click', closeSidebar);
      }

      // é»æ“Šå¤–éƒ¨é—œé–‰å´é‚Šé¢æ¿
      document.addEventListener('click', function(e) {
        if (sidebar.classList.contains('open') && 
            !sidebar.contains(e.target) && 
            !sidebarToggle.contains(e.target)) {
          closeSidebar();
        }
      });

      // ESC éµé—œé–‰å´é‚Šé¢æ¿
      document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape' && sidebar.classList.contains('open')) {
          closeSidebar();
        }
      });

      // --- å»ºç«‹/é‡å»º Viz å¯¦ä¾‹ï¼ˆé¿å… worker å¡ä½ï¼‰ ---
      let viz;
      function newViz() {
        try { viz && viz.terminate && viz.terminate(); } catch (_) {}
        viz = new Viz();
      }
      newViz();

      // --- æ•´é«”ç¸®æ”¾ ---
      function applyZoom(pct) {
        state.scalePct = Math.max(10, Math.min(800, pct));
        applyDragTransform(); // ä½¿ç”¨æ–°çš„æ‹–æ›³è®Šæ›å‡½æ•¸
        zoomLabel.textContent = `${state.scalePct}%`;
        zoomRange.value = String(state.scalePct);
        
        // ç¸®æ”¾å¾Œé‡æ–°èª¿æ•´é é¢å¤§å°
        if (state.origW && state.origH) {
          const scale = state.scalePct / 100;
          const scaledWidth = state.origW * scale;
          const scaledHeight = state.origH * scale;
          adjustPageSizeToGraph(scaledWidth, scaledHeight);
        }
      }
      function fitToWidth() {
        if (!state.origW || !state.origH) return;
        
        const containerWidth = graph.clientWidth;
        const containerHeight = graph.clientHeight - 80; // æ¸›å» header é«˜åº¦
        
        // è¨ˆç®—é©åˆçš„ç¸®æ”¾æ¯”ä¾‹ï¼Œç¢ºä¿åœ°åœ–å®Œå…¨å¯è¦‹
        const scaleX = containerWidth / state.origW;
        const scaleY = containerHeight / state.origH;
        const scale = Math.min(scaleX, scaleY) * 100; // é¸æ“‡è¼ƒå°çš„ç¸®æ”¾æ¯”ä¾‹
        
        // é‡è¨­æ‹–æ›³ä½ç½®åˆ°ä¸­å¿ƒ
        state.currentTranslateX = (containerWidth - state.origW * scale / 100) / 2;
        state.currentTranslateY = (containerHeight - state.origH * scale / 100) / 2;
        
        applyZoom(Math.round(scale));
        console.log('Google Maps é¢¨æ ¼è§€çœ‹å…¨åœ°åœ–ï¼šå·²é‡è¨­ä½ç½®åˆ°ä¸­å¿ƒ');
      }
      function resetZoom() {
        // é‡è¨­ç¸®æ”¾å’Œä½ç½®
        state.currentTranslateX = 0;
        state.currentTranslateY = 0;
        applyZoom(100);
        console.log('Google Maps é¢¨æ ¼é‡è¨­ç¸®æ”¾ï¼šå·²é‡è¨­ä½ç½®å’Œç¸®æ”¾');
      }

      // --- å­—é«”å¤§å° ---
      function applyFontSize(px) {
        state.fontSize = Math.max(6, Math.min(80, px));
        const texts = zoomInner.querySelectorAll("text");
        texts.forEach(t => t.setAttribute("font-size", state.fontSize));
        fontLabel.textContent = `${state.fontSize}px`;
        fontRange.value = state.fontSize;
      }
      function resetFont() { applyFontSize(state.origFontSize); }

      // --- rankdir æ³¨å…¥ï¼ˆåƒ… dot å¼•æ“æœ‰æ•ˆï¼‰ ---
      function applyRankdirToDot(src, dir) {
        try {
          if (!src) return src;
          // ç§»é™¤æ—¢æœ‰ rankdir è¨­å®š
          let cleaned = src.replace(/\brankdir\s*=\s*"?[A-Z]{2}"?\s*;?/gi, "");
          // åœ¨ç¬¬ä¸€å€‹ { ä¹‹å¾Œæ³¨å…¥ rankdir
          const i = cleaned.indexOf('{');
          if (i !== -1) {
            return cleaned.slice(0, i + 1) + `\n  rankdir=${dir};` + cleaned.slice(i + 1);
          }
          return `digraph G { rankdir=${dir}; ${cleaned} }`;
        } catch (e) {
          console.warn('applyRankdirToDot failed, fallback raw DOT');
          return src;
        }
      }

      // --- splines æ³¨å…¥ï¼ˆæ‰€æœ‰å¼•æ“éƒ½æœ‰æ•ˆï¼‰ ---
      function applySplinesToDot(src, splinesType) {
        try {
          if (!src) return src;
          // ç§»é™¤æ—¢æœ‰ splines è¨­å®š
          let cleaned = src.replace(/\bsplines\s*=\s*"?[a-zA-Z]+"?\s*;?/gi, "");
          // åœ¨ç¬¬ä¸€å€‹ { ä¹‹å¾Œæ³¨å…¥ splines
          const i = cleaned.indexOf('{');
          if (i !== -1) {
            return cleaned.slice(0, i + 1) + `\n  splines=${splinesType};` + cleaned.slice(i + 1);
          }
          return `digraph G { splines=${splinesType}; ${cleaned} }`;
        } catch (e) {
          console.warn('applySplinesToDot failed, fallback raw DOT');
          return src;
        }
      }

      // --- ç¯€é»å½¢ç‹€æ³¨å…¥ï¼ˆæ‰€æœ‰å¼•æ“éƒ½æœ‰æ•ˆï¼‰ ---
      function applyNodeShapeToDot(src, shapeType) {
        try {
          if (!src) return src;
          // ç§»é™¤æ—¢æœ‰ shape è¨­å®š
          let cleaned = src.replace(/\bshape\s*=\s*"?[a-zA-Z]+"?\s*;?/gi, "");
          // åœ¨ç¬¬ä¸€å€‹ { ä¹‹å¾Œæ³¨å…¥ç¯€é»å½¢ç‹€
          const i = cleaned.indexOf('{');
          if (i !== -1) {
            return cleaned.slice(0, i + 1) + `\n  node [shape=${shapeType}];` + cleaned.slice(i + 1);
          }
          return `digraph G { node [shape=${shapeType}]; ${cleaned} }`;
        } catch (e) {
          console.warn('applyNodeShapeToDot failed, fallback raw DOT');
          return src;
        }
      }

      // --- ä¾æŒ‡å®šå¼•æ“æ¸²æŸ“ DOT ---
      async function renderGraph() {
        if (!state.dot) return Promise.resolve();
        try {
          console.log(`[render] engine=%s, splines=%s, nodeShape=%s`, state.engine, state.splines, state.nodeShape);
          const src = state.dot;
          let dotToUse = applySplinesToDot(src, state.splines);
          dotToUse = applyNodeShapeToDot(dotToUse, state.nodeShape);
          dotToUse = (state.engine === 'dot') ? applyRankdirToDot(dotToUse, state.rankdir) : dotToUse;
          const svg = await viz.renderSVGElement(dotToUse, { engine: state.engine });

          const rawW = svg.getAttribute("width");
          const rawH = svg.getAttribute("height");
          const origW = rawW ? parseFloat(rawW) : (svg.viewBox?.baseVal?.width || svg.getBBox().width);
          const origH = rawH ? parseFloat(rawH) : (svg.viewBox?.baseVal?.height || svg.getBBox().height);
          state.origW = origW; state.origH = origH;
          
          console.log(`=== Graphviz å°ºå¯¸è³‡è¨Š ===`);
          console.log(`åŸå§‹å¯¬åº¦ (origW): ${origW}px`);
          console.log(`åŸå§‹é«˜åº¦ (origH): ${origH}px`);
          console.log(`SVG width å±¬æ€§: ${rawW}`);
          console.log(`SVG height å±¬æ€§: ${rawH}`);
          console.log(`SVG viewBox: ${svg.viewBox?.baseVal?.width || 'N/A'} x ${svg.viewBox?.baseVal?.height || 'N/A'}`);
          console.log(`SVG getBBox: ${svg.getBBox().width} x ${svg.getBBox().height}`);
          console.log(`========================`);

          const firstText = svg.querySelector("text");
          if (firstText && state.origFontSize === 14 && state.fontSize === 14) {
            state.origFontSize = parseInt(firstText.getAttribute("font-size")) || 14;
            state.fontSize = state.origFontSize;
            fontRange.value = state.origFontSize;
            fontLabel.textContent = `${state.origFontSize}px`;
          }

          // è¨­ç½®åŸå§‹å°ºå¯¸ï¼Œä½†é™åˆ¶åœ¨åˆç†ç¯„åœå…§
          const maxReasonableWidth = window.innerWidth * 3; // æœ€å¤§å¯¬åº¦ç‚ºè¢å¹•å¯¬åº¦çš„3å€
          const maxReasonableHeight = window.innerHeight * 3; // æœ€å¤§é«˜åº¦ç‚ºè¢å¹•é«˜åº¦çš„3å€
          
          const finalWidth = Math.min(origW, maxReasonableWidth);
          const finalHeight = Math.min(origH, maxReasonableHeight);
          
          zoomInner.style.width = finalWidth + "px";
          zoomInner.style.height = finalHeight + "px";
          
          console.log(`åŸå§‹å°ºå¯¸: ${origW}x${origH}, é™åˆ¶å¾Œå°ºå¯¸: ${finalWidth}x${finalHeight}`);

          svg.setAttribute("preserveAspectRatio", "xMidYMid meet");
          if (!svg.getAttribute("viewBox")) svg.setAttribute("viewBox", `0 0 ${origW} ${origH}`);
          svg.removeAttribute("width");
          svg.removeAttribute("height");

          // å‹•æ…‹èª¿æ•´é é¢å¤§å°ä»¥é©æ‡‰åœ°åœ–ï¼ˆä½¿ç”¨é™åˆ¶å¾Œçš„å°ºå¯¸ï¼‰
          adjustPageSizeToGraph(finalWidth, finalHeight);

          // æ·»åŠ æ¼¸å±¤å®šç¾©
          const defs = svg.querySelector('defs') || svg.insertBefore(document.createElementNS('http://www.w3.org/2000/svg', 'defs'), svg.firstChild);
          
          // å‰µå»ºæ¼¸å±¤å®šç¾©ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
          if (!defs.querySelector('#nodeGradient')) {
            const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
            gradient.setAttribute('id', 'nodeGradient');
            gradient.setAttribute('cx', '50%');
            gradient.setAttribute('cy', '50%');
            gradient.setAttribute('r', '50%');
            
            const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
            stop1.setAttribute('offset', '0%');
            stop1.setAttribute('stop-color', 'rgba(160, 82, 45, 1.0)');
            
            const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
            stop2.setAttribute('offset', '100%');
            stop2.setAttribute('stop-color', 'rgba(139, 69, 19, 0)');
            
            gradient.appendChild(stop1);
            gradient.appendChild(stop2);
            defs.appendChild(gradient);
          }

          // ç›´æ¥ä¿®æ”¹æ‰€æœ‰ç¯€é»çš„ fill å±¬æ€§ç‚ºæ¼¸å±¤
          const nodeElements = svg.querySelectorAll('g.node polygon, g.node rect, g.node ellipse');
          nodeElements.forEach(element => {
            element.setAttribute('fill', 'url(#nodeGradient)');
            element.setAttribute('stroke', 'none');
          });

          zoomInner.innerHTML = "";
          zoomInner.appendChild(svg);

          // ç‚ºæ¯å€‹ç¯€é»æ·»åŠ é»æ“Šäº‹ä»¶
          addNodeClickEvents(svg);

          applyZoom(state.scalePct);
          applyFontSize(state.fontSize);
          
          // é‡æ–°æ‡‰ç”¨æ‹–æ›³è®Šæ›ï¼ˆå¦‚æœæœ‰çš„è©±ï¼‰
          if (state.currentTranslateX !== 0 || state.currentTranslateY !== 0) {
            applyDragTransform();
          }
          
          // è‡ªå‹•é©æ‡‰è¢å¹•å¯¬åº¦
          setTimeout(() => {
            fitToWidth();
          }, 100);
        } catch (err) {
          console.error("render error:", err);
          // worker å¯èƒ½å£æ‰ï¼Œé‡å»ºå¾Œå†è©¦ä¸€æ¬¡
          newViz();
          try {
            const src = state.dot;
            let dotToUse = applySplinesToDot(src, state.splines);
            dotToUse = applyNodeShapeToDot(dotToUse, state.nodeShape);
            dotToUse = (state.engine === 'dot') ? applyRankdirToDot(dotToUse, state.rankdir) : dotToUse;
            const svg = await viz.renderSVGElement(dotToUse, { engine: state.engine });
            
            // æ·»åŠ æ¼¸å±¤å®šç¾©
            const defs = svg.querySelector('defs') || svg.insertBefore(document.createElementNS('http://www.w3.org/2000/svg', 'defs'), svg.firstChild);
            
            // å‰µå»ºæ¼¸å±¤å®šç¾©ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
            if (!defs.querySelector('#nodeGradient')) {
              const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'radialGradient');
              gradient.setAttribute('id', 'nodeGradient');
              gradient.setAttribute('cx', '50%');
              gradient.setAttribute('cy', '50%');
              gradient.setAttribute('r', '50%');
              
              const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
              stop1.setAttribute('offset', '0%');
              stop1.setAttribute('stop-color', 'rgba(160, 82, 45, 0.9)');
              
              const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
              stop2.setAttribute('offset', '100%');
              stop2.setAttribute('stop-color', 'rgba(139, 69, 19, 0.4)');
              
              gradient.appendChild(stop1);
              gradient.appendChild(stop2);
              defs.appendChild(gradient);
            }

            // ç›´æ¥ä¿®æ”¹æ‰€æœ‰ç¯€é»çš„ fill å±¬æ€§ç‚ºæ¼¸å±¤
            const nodeElements = svg.querySelectorAll('g.node polygon, g.node rect, g.node ellipse');
            nodeElements.forEach(element => {
              element.setAttribute('fill', 'url(#nodeGradient)');
              element.setAttribute('stroke', 'none');
            });
            
            zoomInner.innerHTML = "";
            zoomInner.appendChild(svg);
            
            // ç‚ºæ¯å€‹ç¯€é»æ·»åŠ é»æ“Šäº‹ä»¶
            addNodeClickEvents(svg);
            
            applyZoom(state.scalePct);
            applyFontSize(state.fontSize);
            
            // é‡æ–°æ‡‰ç”¨æ‹–æ›³è®Šæ›ï¼ˆå¦‚æœæœ‰çš„è©±ï¼‰
            if (state.currentTranslateX !== 0 || state.currentTranslateY !== 0) {
              applyDragTransform();
            }
            
            // è‡ªå‹•é©æ‡‰è¢å¹•å¯¬åº¦
            setTimeout(() => {
              fitToWidth();
            }, 100);
          } catch (e2) {
            graph.textContent = `Graph render failed with engine "${state.engine}".`;
          }
        }
        return Promise.resolve();
      }

      // --- UI ç¶å®š ---
      zoomRange.addEventListener("input", (e) => applyZoom(parseInt(e.target.value, 10)));
      $("zoomIn").addEventListener("click", () => applyZoom(state.scalePct + 10));
      $("zoomOut").addEventListener("click", () => applyZoom(state.scalePct - 10));
      $("fitWidth").addEventListener("click", fitToWidth);
      $("resetZoom").addEventListener("click", resetZoom);

      fontRange.addEventListener("input", (e) => applyFontSize(parseInt(e.target.value, 10)));
      $("fontBigger").addEventListener("click", () => applyFontSize(state.fontSize + 2));
      $("fontSmaller").addEventListener("click", () => applyFontSize(state.fontSize - 2));
      $("resetFont").addEventListener("click", resetFont);
      $("clearPathHighlight").addEventListener("click", clearPathHighlight);
      
      // --- å€‹äººåŒ–è³‡è¨ŠåŠŸèƒ½ ---
      
      // åˆå§‹åŒ–å€‹äººåŒ–è³‡è¨Š
      function initCustomInfo() {
        // æª¢æŸ¥æ˜¯å¦å·²ç¶“æœ‰å„²å­˜çš„å€‹äººåŒ–è³‡è¨Š
        const savedUserInfo = localStorage.getItem('gaso_userInfo');
        if (savedUserInfo) {
          state.userInfo = JSON.parse(savedUserInfo);
          console.log('å·²è¼‰å…¥å€‹äººåŒ–è³‡è¨Š:', state.userInfo);
          updateUserInfoDisplay();
          return; // å¦‚æœå·²æœ‰è³‡è¨Šï¼Œä¸é¡¯ç¤ºè¡¨å–®
        }
        
        // é¡¯ç¤ºå€‹äººåŒ–è³‡è¨Šè¡¨å–®
        showCustomInfoForm();
      }
      
      // æ›´æ–°å€‹äººè³‡è¨Šé¡¯ç¤º
      function updateUserInfoDisplay() {
        const currentUserInfo = document.getElementById('currentUserInfo');
        if (currentUserInfo) {
          if (state.userInfo.role && state.userInfo.title && state.userInfo.gasLevel) {
            currentUserInfo.textContent = `${state.userInfo.role} - ${state.userInfo.title} (${state.userInfo.gasLevel})`;
            currentUserInfo.style.color = '#28a745';
          } else {
            currentUserInfo.textContent = 'æœªè¨­å®šå€‹äººè³‡è¨Š';
            currentUserInfo.style.color = '#666';
          }
        }
      }
      
      // é¡¯ç¤ºå€‹äººåŒ–è³‡è¨Šè¡¨å–®
      function showCustomInfoForm() {
        const modal = document.getElementById('customInfoModal');
        if (modal) {
          modal.style.display = 'block';
          bindCustomInfoEvents();
        }
      }
      
      // é—œé–‰å€‹äººåŒ–è³‡è¨Šè¡¨å–®
      function closeCustomInfoForm() {
        const modal = document.getElementById('customInfoModal');
        if (modal) {
          modal.style.display = 'none';
        }
      }
      
      // ç¶å®šå€‹äººåŒ–è³‡è¨Šè¡¨å–®äº‹ä»¶
      function bindCustomInfoEvents() {
        const userRoleSelect = document.getElementById('userRoleSelect');
        const userRoleCustom = document.getElementById('userRoleCustom');
        const userTitleSelect = document.getElementById('userTitleSelect');
        const userTitleCustom = document.getElementById('userTitleCustom');
        const gasLevelSelect = document.getElementById('gasLevelSelect');
        const gasLevelCustom = document.getElementById('gasLevelCustom');
        const saveBtn = document.getElementById('saveCustomInfo');
        const skipBtn = document.getElementById('skipCustomInfo');
        const closeBtn = document.getElementById('customInfoClose');
        
        // è·è²¬é¸æ“‡äº‹ä»¶
        if (userRoleSelect) {
          userRoleSelect.addEventListener('change', function() {
            if (this.value === 'å…¶ä»–') {
              userRoleCustom.style.display = 'block';
              userRoleCustom.focus();
            } else {
              userRoleCustom.style.display = 'none';
              userRoleCustom.value = '';
            }
          });
        }
        
        // è·ä½é¸æ“‡äº‹ä»¶
        if (userTitleSelect) {
          userTitleSelect.addEventListener('change', function() {
            if (this.value === 'å…¶ä»–') {
              userTitleCustom.style.display = 'block';
              userTitleCustom.focus();
            } else {
              userTitleCustom.style.display = 'none';
              userTitleCustom.value = '';
            }
          });
        }
        
        // æŠ€èƒ½ç­‰ç´šé¸æ“‡äº‹ä»¶
        if (gasLevelSelect) {
          gasLevelSelect.addEventListener('change', function() {
            if (this.value === 'è‡ªè¨‚') {
              gasLevelCustom.style.display = 'block';
              gasLevelCustom.focus();
            } else {
              gasLevelCustom.style.display = 'none';
              gasLevelCustom.value = '';
            }
          });
        }
        
        // å„²å­˜æŒ‰éˆ•äº‹ä»¶
        if (saveBtn) {
          saveBtn.addEventListener('click', function() {
            saveCustomInfo();
          });
        }
        
        // è·³éæŒ‰éˆ•äº‹ä»¶
        if (skipBtn) {
          skipBtn.addEventListener('click', function() {
            closeCustomInfoForm();
          });
        }
        
        // é—œé–‰æŒ‰éˆ•äº‹ä»¶
        if (closeBtn) {
          closeBtn.addEventListener('click', function() {
            closeCustomInfoForm();
          });
        }
      }
      
      // å„²å­˜å€‹äººåŒ–è³‡è¨Š
      function saveCustomInfo() {
        const userRoleSelect = document.getElementById('userRoleSelect');
        const userRoleCustom = document.getElementById('userRoleCustom');
        const userTitleSelect = document.getElementById('userTitleSelect');
        const userTitleCustom = document.getElementById('userTitleCustom');
        const gasLevelSelect = document.getElementById('gasLevelSelect');
        const gasLevelCustom = document.getElementById('gasLevelCustom');
        
        // å–å¾—ä½¿ç”¨è€…è¼¸å…¥çš„è³‡è¨Š
        const role = userRoleSelect.value === 'å…¶ä»–' ? userRoleCustom.value.trim() : userRoleSelect.value;
        const title = userTitleSelect.value === 'å…¶ä»–' ? userTitleCustom.value.trim() : userTitleSelect.value;
        const gasLevel = gasLevelSelect.value === 'è‡ªè¨‚' ? gasLevelCustom.value.trim() : gasLevelSelect.value;
        
        // é©—è­‰å¿…å¡«æ¬„ä½
        if (!role || !title || !gasLevel) {
          alert('è«‹å¡«å¯«æ‰€æœ‰æ¬„ä½');
          return;
        }
        
        // å„²å­˜åˆ° state å’Œ localStorage
        state.userInfo = {
          role: role,
          title: title,
          gasLevel: gasLevel
        };
        
        localStorage.setItem('gaso_userInfo', JSON.stringify(state.userInfo));
        
        console.log('å€‹äººåŒ–è³‡è¨Šå·²å„²å­˜:', state.userInfo);
        
        // æ›´æ–°é¡¯ç¤º
        updateUserInfoDisplay();
        
        // é—œé–‰è¡¨å–®
        closeCustomInfoForm();
      }
      
      // ç·¨è¼¯å€‹äººè³‡è¨Š
      function editCustomInfo() {
        // è¼‰å…¥ç¾æœ‰çš„å€‹äººè³‡è¨Šåˆ°è¡¨å–®
        if (state.userInfo.role) {
          const userRoleSelect = document.getElementById('userRoleSelect');
          const userTitleSelect = document.getElementById('userTitleSelect');
          const gasLevelSelect = document.getElementById('gasLevelSelect');
          
          if (userRoleSelect) userRoleSelect.value = state.userInfo.role;
          if (userTitleSelect) userTitleSelect.value = state.userInfo.title;
          if (gasLevelSelect) gasLevelSelect.value = state.userInfo.gasLevel;
        }
        
        // é¡¯ç¤ºè¡¨å–®
        showCustomInfoForm();
      }
      
      // æ¸…é™¤å€‹äººè³‡è¨Š
      function clearCustomInfo() {
        if (confirm('ç¢ºå®šè¦æ¸…é™¤æ‰€æœ‰å€‹äººè³‡è¨Šå—ï¼Ÿ')) {
          // æ¸…é™¤ state å’Œ localStorage
          state.userInfo = {
            role: "",
            title: "",
            gasLevel: ""
          };
          
          localStorage.removeItem('gaso_userInfo');
          
          // æ›´æ–°é¡¯ç¤º
          updateUserInfoDisplay();
          
          console.log('å€‹äººè³‡è¨Šå·²æ¸…é™¤');
        }
      }
      
      // ç”Ÿæˆå®¢è£½åŒ–çš„ prompt å‰ç¶´
      function generateCustomPromptPrefix() {
        if (!state.userInfo.role || !state.userInfo.title || !state.userInfo.gasLevel) {
          return '';
        }
        
        return `æˆ‘æ˜¯è² è²¬${state.userInfo.role}çš„${state.userInfo.title}ï¼Œæˆ‘å° Google Apps Script ç†Ÿæ‚‰çš„ç¨‹åº¦æ˜¯${state.userInfo.gasLevel}ã€‚\n\n`;
      }
      
      // --- æ‹–æ›³åŠŸèƒ½ï¼ˆé è¨­å•Ÿç”¨ï¼‰ ---
      
      // é‡è¨­ä½ç½®
      function resetPosition() {
        state.currentTranslateX = 0;
        state.currentTranslateY = 0;
        applyDragTransform();
        console.log('ä½ç½®å·²é‡è¨­');
      }
      
      // å›åˆ°ä¸­å¿ƒ
      function centerMap() {
        if (state.origW && state.origH) {
          const scale = state.scalePct / 100;
          const containerWidth = graph.clientWidth;
          const containerHeight = graph.clientHeight;
          const scaledWidth = state.origW * scale;
          const scaledHeight = state.origH * scale;
          
          // è¨ˆç®—ä¸­å¿ƒä½ç½®
          state.currentTranslateX = (containerWidth - scaledWidth) / 2;
          state.currentTranslateY = (containerHeight - scaledHeight) / 2;
          
          applyDragTransform();
          console.log('åœ°åœ–å·²å›åˆ°ä¸­å¿ƒ');
        }
      }
      
      // å›åˆ°èµ·é»åŠŸèƒ½
      function goToStart() {
        // æ‰¾åˆ°èµ·é»ç¯€é»
        const startNodes = findStartNodes();
        if (startNodes.length === 0) {
          console.log('æ‰¾ä¸åˆ°èµ·é»ç¯€é»');
          return;
        }
        
        const startNode = startNodes[0];
        console.log('æ‰¾åˆ°èµ·é»ç¯€é»:', startNode);
        
        // æ‰¾åˆ°èµ·é»ç¯€é»åœ¨ SVG ä¸­çš„ä½ç½®
        const svg = zoomInner.querySelector('svg');
        if (!svg) {
          console.log('æ‰¾ä¸åˆ° SVG å…ƒç´ ');
          return;
        }
        
        // é€šéæ¨™ç±¤æ‰¾åˆ°èµ·é»ç¯€é»å…ƒç´ 
        const nodeDetail = state.nodeDetails.find(n => n.id === startNode);
        if (!nodeDetail) {
          console.log('æ‰¾ä¸åˆ°èµ·é»ç¯€é»è©³ç´°è³‡è¨Š');
          return;
        }
        
        const allNodes = svg.querySelectorAll('g.node');
        let startNodeElement = null;
        
        for (const node of allNodes) {
          const textElement = node.querySelector('text');
          if (textElement && textElement.textContent === nodeDetail.label) {
            startNodeElement = node;
            break;
          }
        }
        
        if (startNodeElement) {
          // è¨­å®šç¸®æ”¾åˆ° 150%
          state.scalePct = 150;
          
          // è¨ˆç®—å®¹å™¨ä¸­å¿ƒ
          const containerWidth = graph.clientWidth;
          const containerHeight = graph.clientHeight;
          
          console.log('å®¹å™¨å°ºå¯¸:', containerWidth, containerHeight);
          
          // ä½¿ç”¨æ›´ç°¡å–®çš„æ–¹æ³•ï¼šç›´æ¥å°‡èµ·é»ç¯€é»ç½®ä¸­
          // å…ˆé‡è¨­ä½ç½®åˆ°åŸé»
          state.currentTranslateX = 0;
          state.currentTranslateY = 0;
          
          // å–å¾—èµ·é»ç¯€é»çš„ä½ç½®
          const bbox = startNodeElement.getBBox();
          const nodeX = bbox.x + bbox.width / 2;
          const nodeY = bbox.y + bbox.height / 2;
          
          console.log('èµ·é»ç¯€é»ä½ç½®:', nodeX, nodeY);
          
          // è¨ˆç®—ç¸®æ”¾æ¯”ä¾‹
          const scale = state.scalePct / 100;
          
          // è¨ˆç®—èµ·é»ç¯€é»åœ¨ç¸®æ”¾å¾Œçš„ä½ç½®
          const scaledNodeX = nodeX * scale;
          const scaledNodeY = nodeY * scale;
          
          console.log('ç¸®æ”¾å¾Œç¯€é»ä½ç½®:', scaledNodeX, scaledNodeY);
          
          // ä¿®æ­£ç½®ä¸­è¨ˆç®—ï¼šæ­£ç¢ºè™•ç†è² åº§æ¨™
          // è¨ˆç®—éœ€è¦ç§»å‹•çš„è·é›¢
          const moveX = (containerWidth / 2) - scaledNodeX;
          const moveY = (containerHeight / 2) - scaledNodeY;
          
          console.log('éœ€è¦ç§»å‹•çš„è·é›¢:', moveX, moveY);
          
          // å°æ–¼è² åº§æ¨™çš„ç¯€é»ï¼Œæˆ‘å€‘éœ€è¦ç‰¹åˆ¥è™•ç†
          // å¦‚æœç¯€é»åœ¨è² åº§æ¨™å€åŸŸï¼Œæˆ‘å€‘éœ€è¦å°‡æ•´å€‹åœ°åœ–å‘ä¸Šç§»å‹•
          let finalX = moveX;
          let finalY = moveY;
          
          // å¦‚æœ Y åº§æ¨™æ˜¯è² å€¼ï¼ˆç¯€é»åœ¨åœ°åœ–ä¸Šæ–¹ï¼‰ï¼Œèª¿æ•´è¨ˆç®—æ–¹å¼
          if (nodeY < 0) {
            // å°æ–¼è²  Y åº§æ¨™ï¼Œæˆ‘å€‘éœ€è¦å°‡åœ°åœ–å‘ä¸Šç§»å‹•æ›´å¤š
            // è®“ç¯€é»èƒ½å¤ é¡¯ç¤ºåœ¨è¢å¹•ä¸­å¤®
            finalY = moveY;
            console.log('æª¢æ¸¬åˆ°è²  Y åº§æ¨™ï¼Œèª¿æ•´è¨ˆç®—æ–¹å¼');
          }
          
          // é™åˆ¶ç§»å‹•ç¯„åœï¼Œé˜²æ­¢åœ°åœ–è·‘åˆ°è¢å¹•å¤–
          const maxMoveX = containerWidth * 0.9; // æ”¾å¯¬é™åˆ¶
          const maxMoveY = containerHeight * 0.9; // æ”¾å¯¬é™åˆ¶
          
          state.currentTranslateX = Math.max(-maxMoveX, Math.min(maxMoveX, finalX));
          state.currentTranslateY = Math.max(-maxMoveY, Math.min(maxMoveY, finalY));
          
          console.log('æœ€çµ‚ä½ç§»:', state.currentTranslateX, state.currentTranslateY);
          
          // æ‡‰ç”¨è®Šæ›
          applyDragTransform();
          zoomLabel.textContent = `${state.scalePct}%`;
          zoomRange.value = String(state.scalePct);
          
          console.log('å·²å›åˆ°èµ·é»ï¼Œç¸®æ”¾åˆ° 150%ï¼Œä½ç½®å·²é‡è¨­åˆ°åŸé»');
        } else {
          console.log('æ‰¾ä¸åˆ°èµ·é»ç¯€é»å…ƒç´ ');
        }
      }
      
      // æ‡‰ç”¨æ‹–æ›³è®Šæ›ï¼ˆGoogle Maps é¢¨æ ¼ï¼‰
      function applyDragTransform() {
        const scale = state.scalePct / 100;
        
        // Google Maps é¢¨æ ¼ï¼šå…è¨±è‡ªç”±æ‹–æ›³ï¼Œä½†æä¾›é©ç•¶çš„é‚Šç•Œé™åˆ¶
        const containerWidth = graph.clientWidth;
        const containerHeight = graph.clientHeight;
        const scaledWidth = state.origW ? state.origW * scale : 0;
        const scaledHeight = state.origH ? state.origH * scale : 0;
        
        // è¨ˆç®—åˆç†çš„æ‹–æ›³é‚Šç•Œ
        const maxTranslateX = Math.max(0, (scaledWidth - containerWidth) / 2 + containerWidth * 0.5);
        const minTranslateX = Math.min(0, -(scaledWidth - containerWidth) / 2 - containerWidth * 0.5);
        const maxTranslateY = Math.max(0, (scaledHeight - containerHeight) / 2 + containerHeight * 0.5);
        const minTranslateY = Math.min(0, -(scaledHeight - containerHeight) / 2 - containerHeight * 0.5);
        
        // æ‡‰ç”¨é‚Šç•Œé™åˆ¶
        state.currentTranslateX = Math.max(minTranslateX, Math.min(maxTranslateX, state.currentTranslateX));
        state.currentTranslateY = Math.max(minTranslateY, Math.min(maxTranslateY, state.currentTranslateY));
        
        zoomInner.style.transform = `translate(${state.currentTranslateX}px, ${state.currentTranslateY}px) scale(${scale})`;
      }
      
      // æ‹–æ›³é–‹å§‹
      function startDrag(e) {
        // é è¨­å•Ÿç”¨æ‹–æ›³ï¼Œä¸éœ€è¦æª¢æŸ¥ isDragMode
        e.preventDefault();
        e.stopPropagation();
        state.isDragging = true;
        graph.classList.add('dragging');
        zoomInner.classList.add('dragging');
        
        state.dragStartX = e.clientX;
        state.dragStartY = e.clientY;
        state.dragOffsetX = state.currentTranslateX;
        state.dragOffsetY = state.currentTranslateY;
        
        console.log('é–‹å§‹æ‹–æ›³ï¼Œèµ·å§‹ä½ç½®:', state.dragStartX, state.dragStartY);
      }
      
      // æ‹–æ›³ä¸­
      function drag(e) {
        if (!state.isDragging) return;
        
        e.preventDefault();
        e.stopPropagation();
        
        const deltaX = e.clientX - state.dragStartX;
        const deltaY = e.clientY - state.dragStartY;
        
        state.currentTranslateX = state.dragOffsetX + deltaX;
        state.currentTranslateY = state.dragOffsetY + deltaY;
        
        console.log('æ‹–æ›³ä¸­ï¼Œåç§»:', deltaX, deltaY, 'æ–°ä½ç½®:', state.currentTranslateX, state.currentTranslateY);
        applyDragTransform();
      }
      
      // æ‹–æ›³çµæŸ
      function endDrag(e) {
        if (!state.isDragging) return;
        
        state.isDragging = false;
        graph.classList.remove('dragging');
        zoomInner.classList.remove('dragging');
        
        console.log('æ‹–æ›³çµæŸ');
      }
      
      // ç¶å®šæ‹–æ›³äº‹ä»¶
      graph.addEventListener('mousedown', startDrag);
      document.addEventListener('mousemove', drag);
      document.addEventListener('mouseup', endDrag);
      
      // æ·»åŠ è§¸æ§æ”¯æ´
      graph.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1) {
          const touch = e.touches[0];
          const mouseEvent = new MouseEvent('mousedown', {
            clientX: touch.clientX,
            clientY: touch.clientY
          });
          startDrag(mouseEvent);
        }
      });
      
      document.addEventListener('touchmove', (e) => {
        if (e.touches.length === 1 && state.isDragging) {
          e.preventDefault();
          const touch = e.touches[0];
          const mouseEvent = new MouseEvent('mousemove', {
            clientX: touch.clientX,
            clientY: touch.clientY
          });
          drag(mouseEvent);
        }
      });
      
      document.addEventListener('touchend', (e) => {
        if (state.isDragging) {
          endDrag(e);
        }
      });
      
      // é˜²æ­¢æ‹–æ›³æ™‚é¸å–æ–‡å­—
      graph.addEventListener('selectstart', (e) => {
        if (state.isDragMode) {
          e.preventDefault();
        }
      });
      
      // ç¶å®šæ–°æŒ‰éˆ•äº‹ä»¶
      $("goToStart").addEventListener("click", goToStart);
      
      // ç¶å®šå€‹äººåŒ–è¨­å®šæŒ‰éˆ•äº‹ä»¶
      $("editCustomInfo").addEventListener("click", editCustomInfo);
      $("clearCustomInfo").addEventListener("click", clearCustomInfo);
      

      // Google Maps é¢¨æ ¼çš„æ»¾è¼ªç¸®æ”¾ï¼ˆå„ªåŒ–ç‰ˆï¼‰
      graph.addEventListener("wheel", (e) => {
        e.preventDefault();
        
        // å–å¾—æ»‘é¼ ç›¸å°æ–¼ç•«å¸ƒçš„ä½ç½®
        const rect = graph.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        // è¨ˆç®—ç¸®æ”¾å‰çš„æ»‘é¼ ç›¸å°æ–¼åœ°åœ–çš„ä½ç½®
        const scale = state.scalePct / 100;
        const mapX = (mouseX - state.currentTranslateX) / scale;
        const mapY = (mouseY - state.currentTranslateY) / scale;
        
        // è¨ˆç®—ç¸®æ”¾è®ŠåŒ–ï¼ˆæ›´å¹³æ»‘çš„ç¸®æ”¾ï¼‰
        const delta = Math.sign(e.deltaY);
        const zoomChange = delta > 0 ? -5 : 5; // æ¸›å°‘ç¸®æ”¾æ­¥é•·ï¼Œæ›´å¹³æ»‘
        const newScale = Math.max(25, Math.min(400, state.scalePct + zoomChange)); // èª¿æ•´ç¸®æ”¾ç¯„åœ
        
        // æ›´æ–°ç¸®æ”¾æ¯”ä¾‹
        state.scalePct = newScale;
        
        // è¨ˆç®—æ–°çš„ä½ç§»ï¼Œä¿æŒæ»‘é¼ ä½ç½®ä¸è®Š
        const newScaleValue = state.scalePct / 100;
        state.currentTranslateX = mouseX - mapX * newScaleValue;
        state.currentTranslateY = mouseY - mapY * newScaleValue;
        
        // æ·»åŠ ç¸®æ”¾å‹•ç•«æ•ˆæœ
        zoomInner.classList.add('zooming');
        
        // æ‡‰ç”¨è®Šæ›
        applyDragTransform();
        zoomLabel.textContent = `${state.scalePct}%`;
        zoomRange.value = String(state.scalePct);
        
        // ç§»é™¤å‹•ç•«é¡åˆ¥
        setTimeout(() => {
          zoomInner.classList.remove('zooming');
        }, 200); // ç¸®çŸ­å‹•ç•«æ™‚é–“
        
        console.log(`Google Maps é¢¨æ ¼ç¸®æ”¾åˆ° ${state.scalePct}%ï¼Œæ»‘é¼ ä½ç½®: (${mouseX}, ${mouseY})`);
      }, { passive: false });

      // ç›£è½ layout åˆ‡æ›
      if (layoutSelect) {
        layoutSelect.addEventListener("change", async (e) => {
          state.engine = e.target.value;
          localStorage.setItem("gv_engine", state.engine);
          console.log(`[engine] changed to %s`, state.engine);
          await renderGraph();
        });
      }
      
      // ç›£è½ rankdir åˆ‡æ›ï¼ˆåƒ… dot æœ‰æ•ˆï¼‰
      if (rankdirSelect) {
        rankdirSelect.addEventListener("change", async (e) => {
          state.rankdir = e.target.value;
          localStorage.setItem("gv_rankdir", state.rankdir);
          await renderGraph(); // é‡æ–°æ¸²æŸ“ï¼›å°é dot å¼•æ“æœ¬ä¾†å°±ä¸æœƒæœ‰å½±éŸ¿
        });
      }

      // ç›£è½ splines åˆ‡æ›ï¼ˆæ‰€æœ‰å¼•æ“éƒ½æœ‰æ•ˆï¼‰
      if (splinesSelect) {
        splinesSelect.addEventListener("change", async (e) => {
          state.splines = e.target.value;
          localStorage.setItem("gv_splines", state.splines);
          console.log(`[splines] changed to %s`, state.splines);
          await renderGraph(); // é‡æ–°æ¸²æŸ“
        });
      }

      // ç›£è½ç¯€é»å½¢ç‹€åˆ‡æ›ï¼ˆæ‰€æœ‰å¼•æ“éƒ½æœ‰æ•ˆï¼‰
      if (nodeShapeSelect) {
        nodeShapeSelect.addEventListener("change", async (e) => {
          state.nodeShape = e.target.value;
          localStorage.setItem("gv_nodeShape", state.nodeShape);
          console.log(`[nodeShape] changed to %s`, state.nodeShape);
          await renderGraph(); // é‡æ–°æ¸²æŸ“
        });
      }
      // --- è·¯å¾‘æŸ¥æ‰¾å’Œé«˜äº®åŠŸèƒ½ ---
      
      // ä½¿ç”¨ BFS æ‰¾åˆ°å¾èµ·é»åˆ°ç›®æ¨™ç¯€é»çš„æœ€çŸ­è·¯å¾‘
      function findPathToNode(targetNodeId) {
        console.log("=== è·¯å¾‘æŸ¥æ‰¾èª¿è©¦ ===");
        console.log("ç›®æ¨™ç¯€é» ID:", targetNodeId);
        
        // æ‰¾åˆ°å¯¦éš›çš„èµ·é»ï¼ˆæ²’æœ‰å…¥é‚Šçš„ç¯€é»ï¼‰
        const startNodes = findStartNodes();
        console.log("æ‰¾åˆ°çš„èµ·é»ç¯€é»:", startNodes);
        
        if (startNodes.length === 0) {
          console.log("æ²’æœ‰æ‰¾åˆ°èµ·é»ç¯€é»");
          return [];
        }
        
        // ä½¿ç”¨ç¬¬ä¸€å€‹èµ·é»ä½œç‚ºèµ·å§‹é»
        const startNode = startNodes[0];
        console.log("ä½¿ç”¨èµ·é»:", startNode);
        
        // æª¢æŸ¥ç›®æ¨™ç¯€é»æ˜¯å¦å­˜åœ¨
        if (!state.adjacencyList[targetNodeId]) {
          console.log(`ç›®æ¨™ç¯€é» '${targetNodeId}' ä¸å­˜åœ¨æ–¼é„°æ¥è¡¨ä¸­`);
          console.log("å¯ç”¨çš„ç¯€é» ID:", Object.keys(state.adjacencyList));
          return [];
        }
        
        // å¾èµ·é»é–‹å§‹å°‹æ‰¾æ‰€æœ‰è·¯å¾‘
        console.log(`å¾èµ·é» '${startNode}' å°‹æ‰¾æ‰€æœ‰è·¯å¾‘åˆ° '${targetNodeId}'`);
        console.log("é„°æ¥è¡¨:", state.adjacencyList);
        const allPaths = findAllPaths(startNode, targetNodeId);
        console.log("æ‰¾åˆ°çš„æ‰€æœ‰è·¯å¾‘:", allPaths);
        return allPaths;
      }
      
      // æ‰¾åˆ°èµ·é»ï¼ˆæ²’æœ‰å…¥é‚Šçš„ç¯€é»ï¼‰
      function findStartNodes() {
        console.log("=== å°‹æ‰¾èµ·é»ç¯€é» ===");
        const allNodes = new Set(Object.keys(state.adjacencyList));
        const hasIncoming = new Set();
        
        console.log("æ‰€æœ‰ç¯€é»:", Array.from(allNodes));
        
        // æ‰¾å‡ºæ‰€æœ‰æœ‰å…¥é‚Šçš„ç¯€é»
        Object.entries(state.adjacencyList).forEach(([source, neighbors]) => {
          neighbors.forEach(neighbor => {
            hasIncoming.add(neighbor);
            console.log(`ç¯€é» ${source} -> ${neighbor} (${neighbor} æœ‰å…¥é‚Š)`);
          });
        });
        
        console.log("æœ‰å…¥é‚Šçš„ç¯€é»:", Array.from(hasIncoming));
        
        // èµ·é»æ˜¯æ²’æœ‰å…¥é‚Šçš„ç¯€é»
        const startNodes = Array.from(allNodes).filter(node => !hasIncoming.has(node));
        console.log("èµ·é»ç¯€é»ï¼ˆæ²’æœ‰å…¥é‚Šçš„ç¯€é»ï¼‰:", startNodes);
        
        return startNodes;
      }
      
      // BFS è·¯å¾‘æŸ¥æ‰¾ - æ‰¾åˆ°æ‰€æœ‰å¯èƒ½çš„è·¯å¾‘
      function findAllPaths(start, target) {
        console.log("=== æŸ¥æ‰¾æ‰€æœ‰è·¯å¾‘é–‹å§‹ ===");
        console.log("èµ·é»:", start);
        console.log("ç›®æ¨™:", target);
        
        const allPaths = [];
        const queue = [[start]];
        let step = 0;
        
        while (queue.length > 0) {
          step++;
          const path = queue.shift();
          const current = path[path.length - 1];
          
          console.log(`æ­¥é©Ÿ ${step}: ç•¶å‰ç¯€é» ${current}, è·¯å¾‘:`, path);
          
          if (current === target) {
            console.log(`æ‰¾åˆ°ç›®æ¨™ç¯€é»ï¼è·¯å¾‘:`, path);
            allPaths.push([...path]);
            continue; // ç¹¼çºŒå°‹æ‰¾å…¶ä»–è·¯å¾‘
          }
          
          const neighbors = state.adjacencyList[current] || [];
          console.log(`ç¯€é» ${current} çš„é„°å±…:`, neighbors);
          
          for (const neighbor of neighbors) {
            // é¿å…å¾ªç’°è·¯å¾‘ï¼ˆåŒä¸€å€‹ç¯€é»åœ¨è·¯å¾‘ä¸­å‡ºç¾å¤šæ¬¡ï¼‰
            if (!path.includes(neighbor)) {
              const newPath = [...path, neighbor];
              queue.push(newPath);
              console.log(`æ·»åŠ æ–°è·¯å¾‘:`, newPath);
            } else {
              console.log(`ç¯€é» ${neighbor} å·²åœ¨è·¯å¾‘ä¸­ï¼Œè·³éä»¥é¿å…å¾ªç’°`);
            }
          }
        }
        
        console.log(`æ‰¾åˆ° ${allPaths.length} æ¢è·¯å¾‘:`, allPaths);
        return allPaths;
      }
      
      // ä¿ç•™åŸä¾†çš„ BFS å‡½æ•¸ä½œç‚ºå‚™ç”¨
      function bfsPath(start, target) {
        const allPaths = findAllPaths(start, target);
        return allPaths.length > 0 ? allPaths[0] : []; // è¿”å›ç¬¬ä¸€æ¢è·¯å¾‘
      }
      
      // é«˜äº®å–®æ¢è·¯å¾‘ä¸Šçš„é‚Š
      function highlightSinglePath(path) {
        if (path.length < 2) return;
        
        const svg = zoomInner.querySelector('svg');
        if (!svg) return;
        
        // é«˜äº®è·¯å¾‘ä¸Šçš„é‚Š
        for (let i = 0; i < path.length - 1; i++) {
          const source = path[i];
          const target = path[i + 1];
          
          // æ‰¾åˆ°å°æ‡‰çš„é‚Šå…ƒç´ 
          const edgeId = `${source}_${target}`;
          const edgeElement = svg.querySelector(`#${edgeId}`);
          
          if (edgeElement) {
            // æ‰¾åˆ°é‚Šå…ƒç´ å…§éƒ¨çš„ path å…ƒç´ ï¼ˆå¯¦éš›ç¹ªè£½ç·šæ¢çš„å…ƒç´ ï¼‰
            const pathElement = edgeElement.querySelector('path');
            const polygonElement = edgeElement.querySelector('polygon'); // ç®­é ­å…ƒç´ 
            
            if (pathElement) {
              // å° path å…ƒç´ æ‡‰ç”¨é«˜äº®æ¨£å¼ - 10px ç¶ è‰²å¯¦ç·š
              pathElement.style.setProperty('stroke', '#00ff00', 'important');
              pathElement.style.setProperty('stroke-width', '10px', 'important');
              pathElement.style.removeProperty('stroke-dasharray'); // ç§»é™¤è™›ç·šï¼Œè®Šæˆå¯¦ç·š
              pathElement.style.setProperty('animation', 'pathPulse 2s infinite', 'important');
              
              // å°ç®­é ­å…ƒç´ ä¹Ÿæ‡‰ç”¨é«˜äº®æ¨£å¼
              if (polygonElement) {
                polygonElement.style.setProperty('fill', '#00ff00', 'important');
                polygonElement.style.setProperty('stroke', '#00ff00', 'important');
              }
              
              // æ·»åŠ é«˜äº®é¡åˆ¥åˆ°æ•´å€‹é‚Šå…ƒç´ 
              edgeElement.classList.add('path-highlighted');
              
              // è¨˜éŒ„é«˜äº®çš„é‚Šå…ƒç´ å’Œå…¶å­å…ƒç´ 
              state.highlightedPath.push({
                edge: edgeElement,
                path: pathElement,
                polygon: polygonElement
              });
              
              console.log(`é«˜äº®é‚Š: ${edgeId}`, { edgeElement, pathElement, polygonElement });
            } else {
              console.log(`é‚Šå…ƒç´  ${edgeId} ä¸­æ‰¾ä¸åˆ° path å…ƒç´ `);
            }
          } else {
            console.log(`æ‰¾ä¸åˆ°é‚Šå…ƒç´ : ${edgeId}`);
          }
        }
      }
      
      // é«˜äº®å¤šæ¢è·¯å¾‘
      function highlightAllPaths(allPaths) {
        // å…ˆæ¸…é™¤ä¹‹å‰çš„é«˜äº®
        clearPathHighlight();
        
        if (allPaths.length === 0) return;
        
        // ç¢ºä¿æ¨£å¼å·²æ·»åŠ 
        addPathHighlightStyles();
        
        console.log(`é–‹å§‹é«˜äº® ${allPaths.length} æ¢è·¯å¾‘`);
        
        // é«˜äº®æ¯æ¢è·¯å¾‘
        allPaths.forEach((path, index) => {
          console.log(`é«˜äº®ç¬¬ ${index + 1} æ¢è·¯å¾‘:`, path);
          highlightSinglePath(path);
        });
        
        console.log(`å®Œæˆé«˜äº®ï¼Œå…±é«˜äº®äº† ${state.highlightedPath.length} æ¢é‚Š`);
      }
      
      // ä¿æŒå‘å¾Œå…¼å®¹çš„å‡½æ•¸
      function highlightPath(path) {
        if (Array.isArray(path) && path.length > 0 && Array.isArray(path[0])) {
          // å¦‚æœå‚³å…¥çš„æ˜¯å¤šæ¢è·¯å¾‘
          highlightAllPaths(path);
        } else {
          // å¦‚æœå‚³å…¥çš„æ˜¯å–®æ¢è·¯å¾‘
          highlightAllPaths([path]);
        }
      }
      
      // æ·»åŠ å‹•ç•«æ¨£å¼å’Œé«˜äº®é¡åˆ¥
      function addPathHighlightStyles() {
        if (!document.getElementById('pathHighlightStyle')) {
          const style = document.createElement('style');
          style.id = 'pathHighlightStyle';
          style.textContent = `
            @keyframes pathPulse {
              0%, 100% { opacity: 1; }
              50% { opacity: 0.6; }
            }
            
            .path-highlighted {
              stroke: #00ff00 !important;
              stroke-width: 10px !important;
              animation: pathPulse 2s infinite !important;
            }
          `;
          document.head.appendChild(style);
        }
      }
      
      // æ¸…é™¤è·¯å¾‘é«˜äº®
      function clearPathHighlight() {
        state.highlightedPath.forEach(highlightedItem => {
          // è™•ç†æ–°çš„æ•¸æ“šçµæ§‹
          if (highlightedItem.edge) {
            // æ¸…é™¤é‚Šå…ƒç´ çš„æ¨£å¼
            highlightedItem.edge.classList.remove('path-highlighted');
            
            // æ¸…é™¤ path å…ƒç´ çš„æ¨£å¼
            if (highlightedItem.path) {
              highlightedItem.path.style.removeProperty('stroke');
              highlightedItem.path.style.removeProperty('stroke-width');
              highlightedItem.path.style.removeProperty('stroke-dasharray');
              highlightedItem.path.style.removeProperty('animation');
            }
            
            // æ¸…é™¤ç®­é ­å…ƒç´ çš„æ¨£å¼
            if (highlightedItem.polygon) {
              highlightedItem.polygon.style.removeProperty('fill');
              highlightedItem.polygon.style.removeProperty('stroke');
            }
          } else {
            // è™•ç†èˆŠçš„æ•¸æ“šçµæ§‹ï¼ˆå‘å¾Œå…¼å®¹ï¼‰
            highlightedItem.style.removeProperty('stroke');
            highlightedItem.style.removeProperty('stroke-width');
            highlightedItem.style.removeProperty('stroke-dasharray');
            highlightedItem.style.removeProperty('animation');
            highlightedItem.classList.remove('path-highlighted');
          }
        });
        state.highlightedPath = [];
        console.log("å·²æ¸…é™¤æ‰€æœ‰è·¯å¾‘é«˜äº®");
      }

      // --- ç¯€é»é»æ“Šäº‹ä»¶è™•ç† ---
      function addNodeClickEvents(svg) {
        const nodes = svg.querySelectorAll('g.node');
        nodes.forEach(node => {
          node.style.cursor = 'pointer';
          
          // æ·»åŠ  hover æ•ˆæœ
          node.addEventListener('mouseenter', () => {
            node.style.opacity = '0.8';
          });
          
          node.addEventListener('mouseleave', () => {
            node.style.opacity = '1';
          });
          
          // æ·»åŠ é»æ“Šäº‹ä»¶
          node.addEventListener('click', (e) => {
            e.stopPropagation();
            const svgNodeId = node.id; // SVG ä¸­çš„ç¯€é» ID (å¦‚ node40)
            const nodeLabel = node.querySelector('text')?.textContent || svgNodeId;
            
            // èª¿è©¦ä¿¡æ¯ï¼šé¡¯ç¤ºæ‰€æœ‰å¯ç”¨çš„ç¯€é» ID
            console.log("=== èª¿è©¦ä¿¡æ¯ ===");
            console.log("SVG ç¯€é» ID:", svgNodeId);
            console.log("ç¯€é»æ¨™ç±¤:", nodeLabel);
            console.log("é„°æ¥è¡¨ä¸­çš„æ‰€æœ‰ç¯€é» ID:", Object.keys(state.adjacencyList));
            console.log("nodeDetails ä¸­çš„æ‰€æœ‰ç¯€é»:", state.nodeDetails.map(n => ({id: n.id, label: n.label})));
            
            // é€šéæ¨™ç±¤æ‰¾åˆ°å¯¦éš›çš„ç¯€é» ID
            const actualNodeDetail = state.nodeDetails.find(n => n.label === nodeLabel);
            const actualNodeId = actualNodeDetail ? actualNodeDetail.id : svgNodeId;
            
            console.log("é€šéæ¨™ç±¤æ‰¾åˆ°çš„å¯¦éš›ç¯€é» ID:", actualNodeId);
            
            // æŸ¥æ‰¾ä¸¦é«˜äº®æ‰€æœ‰è·¯å¾‘
            const allPaths = findPathToNode(actualNodeId);
            if (allPaths.length > 0) {
              console.log(`æ‰¾åˆ°å¾èµ·é»åˆ° ${actualNodeId} çš„ ${allPaths.length} æ¢è·¯å¾‘:`, allPaths);
              highlightPath(allPaths);
            } else {
              console.log(`æ‰¾ä¸åˆ°å¾èµ·é»åˆ° ${actualNodeId} çš„è·¯å¾‘`);
              console.log("å¯èƒ½çš„åŸå› ï¼š");
              console.log("1. ç¯€é» ID ä¸åŒ¹é…");
              console.log("2. èµ·é»ä¸å­˜åœ¨");
              console.log("3. åœ–å½¢ä¸é€£é€š");
              clearPathHighlight();
            }
            
            showNodeInfo(actualNodeId, nodeLabel);
          });
        });
      }

      // --- é¡¯ç¤ºç¯€é»è³‡è¨Š ---
      function showNodeInfo(nodeId, nodeLabel) {
        console.log("å°‹æ‰¾ç¯€é»:", nodeId, "æ¨™ç±¤:", nodeLabel, "åœ¨ nodeDetails ä¸­:", state.nodeDetails);
        // å…ˆå˜—è©¦ç”¨ ID åŒ¹é…
        let nodeDetail = state.nodeDetails.find(n => n.id === nodeId);
        // å¦‚æœæ‰¾ä¸åˆ°ï¼Œå˜—è©¦ç”¨æ¨™ç±¤åŒ¹é…
        if (!nodeDetail) {
          nodeDetail = state.nodeDetails.find(n => n.label === nodeLabel);
          console.log("ç”¨æ¨™ç±¤åŒ¹é…æ‰¾åˆ°çš„ nodeDetail:", nodeDetail);
        } else {
          console.log("ç”¨ ID åŒ¹é…æ‰¾åˆ°çš„ nodeDetail:", nodeDetail);
        }
        if (nodeDetail) {
          showCustomModal(nodeDetail);
        } else {
          // å¦‚æœæ‰¾ä¸åˆ°è©³ç´°è³‡è¨Šï¼Œé¡¯ç¤ºåŸºæœ¬è³‡è¨Š
          showCustomModal({
            id: nodeId,
            label: nodeLabel,
            attribute: "",
            status: "",
            statusText: "æœªçŸ¥",
            prompt: "æ­¤ç¯€é»æ²’æœ‰è©³ç´°è³‡è¨Šã€‚",
            color: "white"
          });
        }
      }

      // --- è¤‡è£½ Prompt åˆ°å‰ªè²¼ç°¿ ---
      async function copyPromptToClipboard(promptText) {
        try {
          // ä½¿ç”¨ç¾ä»£çš„ Clipboard API
          if (navigator.clipboard && window.isSecureContext) {
            await navigator.clipboard.writeText(promptText);
            showCopySuccess();
          } else {
            // é™ç´šæ–¹æ¡ˆï¼šä½¿ç”¨å‚³çµ±çš„ document.execCommand
            const textArea = document.createElement('textarea');
            textArea.value = promptText;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            const successful = document.execCommand('copy');
            document.body.removeChild(textArea);
            
            if (successful) {
              showCopySuccess();
            } else {
              showCopyError();
            }
          }
        } catch (err) {
          console.error('è¤‡è£½å¤±æ•—:', err);
          showCopyError();
        }
      }

      // é¡¯ç¤ºè¤‡è£½æˆåŠŸå›é¥‹
      function showCopySuccess() {
        // æ‰¾åˆ°æ‰€æœ‰è¤‡è£½æŒ‰éˆ•ä¸¦æ›´æ–°ç‹€æ…‹
        const copyButtons = document.querySelectorAll('.copy-button');
        copyButtons.forEach(button => {
          const originalText = button.textContent;
          button.classList.add('copied');
          button.textContent = 'å·²è¤‡è£½';
          
          // 2ç§’å¾Œæ¢å¾©åŸç‹€
          setTimeout(() => {
            button.classList.remove('copied');
            button.textContent = originalText;
          }, 2000);
        });
      }

      // é¡¯ç¤ºè¤‡è£½éŒ¯èª¤å›é¥‹
      function showCopyError() {
        const copyButtons = document.querySelectorAll('.copy-button');
        copyButtons.forEach(button => {
          const originalText = button.textContent;
          button.style.background = '#dc3545';
          button.textContent = 'è¤‡è£½å¤±æ•—';
          
          // 2ç§’å¾Œæ¢å¾©åŸç‹€
          setTimeout(() => {
            button.style.background = '';
            button.textContent = originalText;
          }, 2000);
        });
      }

      // --- è‡ªå®šç¾©å½ˆå‡ºè¦–çª— ---
      function showCustomModal(nodeDetail) {
        console.log("é¡¯ç¤ºç¯€é»è©³æƒ…:", nodeDetail);
        const modal = document.getElementById('nodeModal');
        const title = document.getElementById('modalTitle');
        const content = document.getElementById('modalContent');
        
        // ç”Ÿæˆå®¢è£½åŒ–çš„ prompt
        const customPrefix = generateCustomPromptPrefix();
        const fullPrompt = customPrefix + nodeDetail.prompt;
        
        // å–å¾—ç¯€é»åº§æ¨™è³‡è¨Š
        const nodeCoordinates = getNodeCoordinates(nodeDetail.id);
        
        title.textContent = `${nodeDetail.label}`;
        content.innerHTML = `
          <div class="node-info">
            <div class="info-row">
              <span class="info-label">ID:</span>
              <span class="info-value">${nodeDetail.id}</span>
            </div>
            ${nodeDetail.attribute ? `
            <div class="info-row">
              <span class="info-label">å±¬æ€§:</span>
              <span class="info-value">${nodeDetail.attribute}</span>
            </div>
            ` : ''}
            ${nodeCoordinates ? `
            <div class="info-row">
              <span class="info-label">åº§æ¨™:</span>
              <span class="info-value">X: ${nodeCoordinates.x.toFixed(2)}, Y: ${nodeCoordinates.y.toFixed(2)}</span>
            </div>
            ` : ''}
            <div class="info-row">
              <span class="info-label">æç¤º:</span>
              <div class="info-prompt">
                ${fullPrompt}
                <button class="copy-button" onclick="copyPromptToClipboard('${fullPrompt.replace(/'/g, "\\'")}')">è¤‡è£½</button>
              </div>
            </div>
            ${state.userInfo.role && state.userInfo.title && state.userInfo.gasLevel ? `
            <div class="info-row">
              <span class="info-label">å€‹äººåŒ–:</span>
              <span class="info-value">å·²å¥—ç”¨æ‚¨çš„å€‹äººè³‡è¨Š</span>
            </div>
            ` : ''}
          </div>
        `;
        
        modal.style.display = 'block';
      }
      
      // å–å¾—ç¯€é»åº§æ¨™è³‡è¨Š
      function getNodeCoordinates(nodeId) {
        const svg = zoomInner.querySelector('svg');
        if (!svg) return null;
        
        // æ‰¾åˆ°å°æ‡‰çš„ç¯€é»å…ƒç´ 
        const nodeDetail = state.nodeDetails.find(n => n.id === nodeId);
        if (!nodeDetail) return null;
        
        const allNodes = svg.querySelectorAll('g.node');
        let nodeElement = null;
        
        for (const node of allNodes) {
          const textElement = node.querySelector('text');
          if (textElement && textElement.textContent === nodeDetail.label) {
            nodeElement = node;
            break;
          }
        }
        
        if (nodeElement) {
          try {
            // å–å¾—ç¯€é»çš„é‚Šç•Œæ¡†
            const bbox = nodeElement.getBBox();
            return {
              x: bbox.x + bbox.width / 2,  // ç¯€é»ä¸­å¿ƒ X åº§æ¨™
              y: bbox.y + bbox.height / 2  // ç¯€é»ä¸­å¿ƒ Y åº§æ¨™
            };
          } catch (e) {
            console.log('ç„¡æ³•å–å¾—ç¯€é»åº§æ¨™:', e);
            return null;
          }
        }
        
        return null;
      }

      // --- å½ˆå‡ºè¦–çª—äº‹ä»¶è™•ç† ---
      // ä¿®å¾©ç¯€é»è³‡è¨Šå½ˆå‡ºè¦–çª—é—œé–‰æŒ‰éˆ•
      document.addEventListener('DOMContentLoaded', function() {
        const nodeModalClose = document.querySelector('#nodeModal .close');
        if (nodeModalClose) {
          nodeModalClose.onclick = function() {
            document.getElementById('nodeModal').style.display = 'none';
          }
        }
        
        // ä¿®å¾©å€‹äººåŒ–è³‡è¨Šå½ˆå‡ºè¦–çª—é—œé–‰æŒ‰éˆ•
        const customInfoModalClose = document.querySelector('#customInfoModal .close');
        if (customInfoModalClose) {
          customInfoModalClose.onclick = function() {
            document.getElementById('customInfoModal').style.display = 'none';
          }
        }
      });

      window.onclick = function(event) {
        const nodeModal = document.getElementById('nodeModal');
        const customInfoModal = document.getElementById('customInfoModal');
        
        if (event.target == nodeModal) {
          nodeModal.style.display = 'none';
        }
        
        if (event.target == customInfoModal) {
          customInfoModal.style.display = 'none';
        }
      }

      // æŒ‰ ESC éµé—œé–‰å½ˆå‡ºè¦–çª—
      document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape') {
          const nodeModal = document.getElementById('nodeModal');
          const customInfoModal = document.getElementById('customInfoModal');
          
          if (nodeModal && nodeModal.style.display === 'block') {
            nodeModal.style.display = 'none';
          }
          
          if (customInfoModal && customInfoModal.style.display === 'block') {
            customInfoModal.style.display = 'none';
          }
        }
      });

      // --- æœå°‹åŠŸèƒ½ ---
      
      // é«˜äº®æœå°‹é—œéµå­—
      function highlightText(text, keyword) {
        if (!keyword) return text;
        const regex = new RegExp(`(${keyword})`, 'gi');
        return text.replace(regex, '<span class="search-result-highlight">$1</span>');
      }

      // æœå°‹ç¯€é»
      function searchNodes(keyword) {
        if (!keyword || keyword.length < 1) {
          searchResults.classList.remove('show');
          return;
        }

        const results = state.nodeDetails.filter(node => {
          const searchText = `${node.label} ${node.prompt} ${node.attribute}`.toLowerCase();
          return searchText.includes(keyword.toLowerCase());
        });

        displaySearchResults(results, keyword);
      }

      // é¡¯ç¤ºæœå°‹çµæœ
      function displaySearchResults(results, keyword) {
        if (results.length === 0) {
          searchResults.innerHTML = '<div class="no-results">æ‰¾ä¸åˆ°ç¬¦åˆæ¢ä»¶çš„ç¯€é»</div>';
        } else {
          searchResults.innerHTML = results.map(node => `
            <div class="search-result-item" data-node-id="${node.id}">
              <div class="search-result-title">${highlightText(node.label, keyword)}</div>
              <div class="search-result-subtitle">${highlightText(node.prompt.substring(0, 100) + (node.prompt.length > 100 ? '...' : ''), keyword)}</div>
            </div>
          `).join('');
        }
        searchResults.classList.add('show');
      }

      // è™•ç†æœå°‹çµæœé»æ“Š
      function handleSearchResultClick(nodeId) {
        console.log("=== æœå°‹çµæœé»æ“Šèª¿è©¦ ===");
        console.log("é»æ“Šçš„ç¯€é» ID:", nodeId);
        
        // æ‰¾åˆ°å°æ‡‰çš„ç¯€é»ä¸¦è§¸ç™¼é»æ“Š
        const svg = zoomInner.querySelector('svg');
        if (!svg) {
          console.log("æ‰¾ä¸åˆ° SVG å…ƒç´ ");
          return;
        }

        // é€šéç¯€é»æ¨™ç±¤æ‰¾åˆ°å°æ‡‰çš„ SVG ç¯€é»
        const nodeDetail = state.nodeDetails.find(n => n.id === nodeId);
        if (!nodeDetail) {
          console.log("æ‰¾ä¸åˆ°ç¯€é»è©³ç´°è³‡è¨Š");
          return;
        }

        console.log("ç¯€é»è©³ç´°è³‡è¨Š:", nodeDetail);
        
        // é€šéæ¨™ç±¤æ–‡å­—æ‰¾åˆ°å°æ‡‰çš„ SVG ç¯€é»
        const allNodes = svg.querySelectorAll('g.node');
        let nodeElement = null;
        
        for (const node of allNodes) {
          const textElement = node.querySelector('text');
          if (textElement && textElement.textContent === nodeDetail.label) {
            nodeElement = node;
            break;
          }
        }

        console.log("æ‰¾åˆ°çš„ç¯€é»å…ƒç´ :", nodeElement);
        console.log("ç¯€é»å…ƒç´  ID:", nodeElement ? nodeElement.id : "ç„¡");
        
        if (nodeElement) {
          console.log("è§¸ç™¼ç¯€é»é»æ“Šäº‹ä»¶");
          // æ¨¡æ“¬ç¯€é»é»æ“Šäº‹ä»¶
          const clickEvent = new MouseEvent('click', {
            bubbles: true,
            cancelable: true,
            view: window
          });
          nodeElement.dispatchEvent(clickEvent);
          
          // éš±è—æœå°‹çµæœ
          searchResults.classList.remove('show');
          searchInput.value = '';
        } else {
          console.log("æ‰¾ä¸åˆ°å°æ‡‰çš„ç¯€é»å…ƒç´ ï¼Œç›´æ¥é¡¯ç¤ºç¯€é»è³‡è¨Š");
          // å¦‚æœæ‰¾ä¸åˆ°ç¯€é»ï¼Œç›´æ¥èª¿ç”¨ showNodeInfo
          showNodeInfo(nodeDetail.id, nodeDetail.label);
          // éš±è—æœå°‹çµæœ
          searchResults.classList.remove('show');
          searchInput.value = '';
        }
      }

      // æœå°‹è¼¸å…¥äº‹ä»¶ç›£è½
      if (searchInput) {
        let searchTimeout;
        searchInput.addEventListener('input', function(e) {
          clearTimeout(searchTimeout);
          searchTimeout = setTimeout(() => {
            searchNodes(e.target.value);
          }, 150); // 150ms å»¶é²ï¼Œé¿å…éæ–¼é »ç¹çš„æœå°‹
        });

        // é»æ“Šæœå°‹çµæœ
        searchResults.addEventListener('click', function(e) {
          console.log("æœå°‹çµæœè¢«é»æ“Š:", e.target);
          const resultItem = e.target.closest('.search-result-item');
          console.log("æ‰¾åˆ°çš„çµæœé …ç›®:", resultItem);
          if (resultItem) {
            const nodeId = resultItem.dataset.nodeId;
            console.log("ç¯€é» ID:", nodeId);
            handleSearchResultClick(nodeId);
          } else {
            console.log("æ²’æœ‰æ‰¾åˆ°çµæœé …ç›®");
          }
        });

        // é»æ“Šå¤–éƒ¨é—œé–‰æœå°‹çµæœ
        document.addEventListener('click', function(e) {
          if (!searchInput.contains(e.target) && !searchResults.contains(e.target)) {
            searchResults.classList.remove('show');
          }
        });
      }

      // --- è¼‰å…¥å‹•ç•«æ§åˆ¶ ---
      function hideLoadingAnimation() {
        const loadingContainer = document.getElementById('loadingContainer');
        if (loadingContainer) {
          loadingContainer.classList.add('hidden');
          // å‹•ç•«å®Œæˆå¾Œç§»é™¤å…ƒç´ 
          setTimeout(() => {
            loadingContainer.style.display = 'none';
          }, 500);
        }
      }

      function showLoadingAnimation() {
        const loadingContainer = document.getElementById('loadingContainer');
        if (loadingContainer) {
          loadingContainer.style.display = 'flex';
          loadingContainer.classList.remove('hidden');
        }
      }

      // --- å‹•æ…‹èª¿æ•´é é¢å¤§å°ï¼ˆGoogle Maps é¢¨æ ¼ï¼‰ ---
      function adjustPageSizeToGraph(graphWidth, graphHeight) {
        // Google Maps é¢¨æ ¼ï¼šä¸éœ€è¦èª¿æ•´é é¢å¤§å°ï¼Œåœ°åœ–å®¹å™¨å·²ç¶“æ˜¯å…¨è¢å¹•
        console.log(`åœ°åœ–å°ºå¯¸: ${graphWidth}x${graphHeight} (Google Maps é¢¨æ ¼ï¼Œç„¡éœ€èª¿æ•´é é¢å¤§å°)`);
      }

      // --- Google Maps é¢¨æ ¼ä¸éœ€è¦ç§»é™¤ç©ºç™½ ---
      function removeExcessWhitespace() {
        // Google Maps é¢¨æ ¼ï¼šåœ°åœ–å®¹å™¨å·²ç¶“æ˜¯å…¨è¢å¹•ï¼Œä¸éœ€è¦ç§»é™¤ç©ºç™½
        console.log('Google Maps é¢¨æ ¼ï¼šç„¡éœ€ç§»é™¤ç©ºç™½');
      }

      // --- å–å¾— DOT ä¸¦æ¸²æŸ“ï¼ˆå« logï¼‰ ---
      function applyBackgroundFromConfig(url) {
        if (typeof url === 'string' && url.trim()) {
          state.backgroundImageUrl = url.trim();
          // è¦†å¯«èƒŒæ™¯åœ–ï¼ˆè‹¥æä¾›çš„æ˜¯å®Œæ•´ URLï¼‰
          const bg = `url("${state.backgroundImageUrl}")`;
          zoomInner.style.backgroundImage = bg;
        }
      }

      // --- Debug è³‡è¨Šæ›´æ–°å‡½æ•¸ ---
      function updateDebugInfo() {
        try {
          const screenWidth = window.innerWidth;
          const screenHeight = window.innerHeight;
          const containerWidth = graph ? graph.clientWidth : 0;
          const containerHeight = graph ? graph.clientHeight : 0;
          const svgWidth = zoomInner ? zoomInner.clientWidth : 0;
          const svgHeight = zoomInner ? zoomInner.clientHeight : 0;
          
          const screenWidthEl = document.getElementById("screenWidth");
          const screenHeightEl = document.getElementById("screenHeight");
          const containerWidthEl = document.getElementById("containerWidth");
          const containerHeightEl = document.getElementById("containerHeight");
          const svgWidthEl = document.getElementById("svgWidth");
          const svgHeightEl = document.getElementById("svgHeight");
          
          if (screenWidthEl) screenWidthEl.textContent = screenWidth + "px";
          if (screenHeightEl) screenHeightEl.textContent = screenHeight + "px";
          if (containerWidthEl) containerWidthEl.textContent = containerWidth + "px";
          if (containerHeightEl) containerHeightEl.textContent = containerHeight + "px";
          if (svgWidthEl) svgWidthEl.textContent = svgWidth + "px";
          if (svgHeightEl) svgHeightEl.textContent = svgHeight + "px";
        } catch (e) {
          console.error("Debug æ›´æ–°éŒ¯èª¤:", e);
        }
      }
      
      // å®šæœŸæ›´æ–° debug è³‡è¨Š
      setInterval(updateDebugInfo, 1000);
      window.addEventListener("resize", updateDebugInfo);
      
      // é¡¯ç¤ºè¼‰å…¥å‹•ç•«
      showLoadingAnimation();

      google.script.run
        .withSuccessHandler(function (data) {
          console.log("Graphviz è³‡æ–™ï¼š", data);
          state.dot = data.dot;
          state.nodeDetails = data.nodeDetails;
          state.edgeDetails = data.edgeDetails;
          state.adjacencyList = data.adjacencyList;
          applyBackgroundFromConfig(data.backgroundImageUrl);
          
          // æ¸²æŸ“å®Œæˆå¾Œéš±è—è¼‰å…¥å‹•ç•«
          renderGraph().then(() => {
            hideLoadingAnimation();
            // å»¶é²ä¸€é»æ™‚é–“ç¢ºä¿ DOM å®Œå…¨æ¸²æŸ“å¾Œå†èª¿æ•´
            setTimeout(() => {
              removeExcessWhitespace();
            }, 100);
          });
        })
        .withFailureHandler(function (err) {
          console.error('å–å¾—è³‡æ–™å¤±æ•—ï¼š', err);
          const msg = (err && err.message) ? err.message : 'è¼‰å…¥è³‡æ–™æ™‚ç™¼ç”ŸæœªçŸ¥éŒ¯èª¤ã€‚';
          graph.innerHTML = `<div style="padding:16px;color:#b00020">${msg}</div>`;
          // å³ä½¿å¤±æ•—ä¹Ÿè¦éš±è—è¼‰å…¥å‹•ç•«
          hideLoadingAnimation();
        })
        .getGraphData();
    </script>
  </body>
</html>

